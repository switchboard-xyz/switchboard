"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[985],{54852:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var a=t(49231);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(t),m=r,f=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(f,s(s({ref:n},u),{},{components:t})):a.createElement(f,s({ref:n},u))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[p]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},30501:(e,n,t)=>{t.d(n,{Z:()=>u});var a=t(95907),r=t(49231),o=t(37681),s=t(10422),i=t(62428);function l(e){let{toc:n,className:t,linkClassName:a,isChild:o}=e;return n.length?r.createElement("ul",{className:o?void 0:t},n.map((e=>r.createElement("li",{key:e.id},r.createElement("a",{href:`#${e.id}`,className:a??void 0,dangerouslySetInnerHTML:{__html:e.value}}),r.createElement(l,{isChild:!0,toc:e.children,className:t,linkClassName:a}))))):null}const c=r.memo(l);function u(e){let{toc:n,className:t="table-of-contents table-of-contents__left-border",linkClassName:l="table-of-contents__link",linkActiveClassName:u,minHeadingLevel:p,maxHeadingLevel:d,...m}=e;const f=(0,o.L)(),h=p??f.tableOfContents.minHeadingLevel,g=d??f.tableOfContents.maxHeadingLevel,b=(0,s.b)({toc:n,minHeadingLevel:h,maxHeadingLevel:g}),v=(0,r.useMemo)((()=>{if(l&&u)return{linkClassName:l,linkActiveClassName:u,minHeadingLevel:h,maxHeadingLevel:g}}),[l,u,h,g]);return(0,i.S)(v),r.createElement(c,(0,a.Z)({toc:b,className:t,linkClassName:l},m))}},62428:(e,n,t)=>{t.d(n,{S:()=>l});var a=t(49231),r=t(37681);function o(e){const n=e.getBoundingClientRect();return n.top===n.bottom?o(e.parentNode):n}function s(e,n){let{anchorTopOffset:t}=n;const a=e.find((e=>o(e).top>=t));if(a){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(o(a))?a:e[e.indexOf(a)-1]??null}return e[e.length-1]??null}function i(){const e=(0,a.useRef)(0),{navbar:{hideOnScroll:n}}=(0,r.L)();return(0,a.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function l(e){const n=(0,a.useRef)(void 0),t=i();(0,a.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:a,linkActiveClassName:r,minHeadingLevel:o,maxHeadingLevel:i}=e;function l(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(a),l=function(e){let{minHeadingLevel:n,maxHeadingLevel:t}=e;const a=[];for(let r=n;r<=t;r+=1)a.push(`h${r}.anchor`);return Array.from(document.querySelectorAll(a.join()))}({minHeadingLevel:o,maxHeadingLevel:i}),c=s(l,{anchorTopOffset:t.current}),u=e.find((e=>c&&c.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(r),e.classList.add(r),n.current=e):e.classList.remove(r)}(e,e===u)}))}return document.addEventListener("scroll",l),document.addEventListener("resize",l),l(),()=>{document.removeEventListener("scroll",l),document.removeEventListener("resize",l)}}),[e,t])}},10422:(e,n,t)=>{t.d(n,{a:()=>o,b:()=>i});var a=t(49231);function r(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),t=Array(7).fill(-1);n.forEach(((e,n)=>{const a=t.slice(2,e.level);e.parentIndex=Math.max(...a),t[e.level]=n}));const a=[];return n.forEach((e=>{const{parentIndex:t,...r}=e;t>=0?n[t].children.push(r):a.push(r)})),a}function o(e){return(0,a.useMemo)((()=>r(e)),[e])}function s(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:a}=e;return n.flatMap((e=>{const n=s({toc:e.children,minHeadingLevel:t,maxHeadingLevel:a});return function(e){return e.level>=t&&e.level<=a}(e)?[{...e,children:n}]:n}))}function i(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:o}=e;return(0,a.useMemo)((()=>s({toc:r(n),minHeadingLevel:t,maxHeadingLevel:o})),[n,t,o])}},73594:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>g,frontMatter:()=>c,metadata:()=>p,toc:()=>m});var a=t(95907),r=t(49231),o=t(54852),s=t(30501);const i={tableOfContentsInline:"tableOfContentsInline_shD0"};function l(e){let{toc:n,minHeadingLevel:t,maxHeadingLevel:a}=e;return r.createElement("div",{className:i.tableOfContentsInline},r.createElement(s.Z,{toc:n,minHeadingLevel:t,maxHeadingLevel:a,className:"table-of-contents",linkClassName:null}))}const c={sidebar_position:5,title:"VRF Integration"},u=void 0,p={unversionedId:"solana/guides/vrf/index",id:"solana/guides/vrf/index",title:"VRF Integration",description:"This guide contains a step-by-step walkthrough to integrate Switchboard's VRF in",source:"@site/docs/solana/guides/vrf/index.mdx",sourceDirName:"solana/guides/vrf",slug:"/solana/guides/vrf/",permalink:"/solana/guides/vrf/",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"VRF Integration"},sidebar:"solanaSidebar",previous:{title:"Priority Fees",permalink:"/solana/guides/feeds/priority-fees"},next:{title:"Test Integration",permalink:"/solana/guides/test-integration"}},d={},m=[{value:"1. Anchor Init",id:"1-anchor-init",level:2},{value:"2. Add Dependencies",id:"2-add-dependencies",level:2},{value:"3. Initial Program Scaffolding",id:"3-initial-program-scaffolding",level:2},{value:"4. Setup Switchboard Environment",id:"4-setup-switchboard-environment",level:2},{value:"5. Add init_client Instruction",id:"5-add-init_client-instruction",level:2},{value:"6. Add Request Randomness Instruction",id:"6-add-request-randomness-instruction",level:2},{value:"7. Add Consume Randomness Instruction",id:"7-add-consume-randomness-instruction",level:2},{value:"8. Deployment Instructions",id:"8-deployment-instructions",level:2},{value:"Deploying to Devnet",id:"deploying-to-devnet",level:3},{value:"Deploying to Mainnet",id:"deploying-to-mainnet",level:3}],f={toc:m},h="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(h,(0,a.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This guide contains a step-by-step walkthrough to integrate Switchboard's VRF in\na brand new anchor program."),(0,o.kt)(l,{toc:m,mdxType:"TOCInline"}),(0,o.kt)("p",null,"Switchboard's Verifiable Randomness Function (VRF) allows a user to request an\noracle to produce a randomness output on-chain. Once the oracle has responded,\nthe VRF proof must be verified before using it. The VRF proof takes 276\ninstructions (~48 transactions) to fully verify on-chain. Once the proof is\nverified, the Switchboard program will execute the callback defined by the VRF\nAccount during account creation."),(0,o.kt)("p",null,"Our client program will be very basic. It will initialize a state account to\nhold our randomness result. It will then request randomness from our Switchboard\noracle. Once verified, the Switchboard program will call the consume_randomness\ninstruction which will update our client's state."),(0,o.kt)("p",null,"So the full flow will look like this,"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"derive our client program derived address, ",(0,o.kt)("inlineCode",{parentName:"li"},"vrfClientKey")),(0,o.kt)("li",{parentName:"ul"},"create a Switchboard VRF Account with ",(0,o.kt)("inlineCode",{parentName:"li"},"vrfClientKey")," as the authority. This\nwill allow the client program to sign and request randomness."),(0,o.kt)("li",{parentName:"ul"},"invoke ",(0,o.kt)("inlineCode",{parentName:"li"},"init_client")," for our ",(0,o.kt)("inlineCode",{parentName:"li"},"vrfClientKey")," with our VRF Account"),(0,o.kt)("li",{parentName:"ul"},"invoke ",(0,o.kt)("inlineCode",{parentName:"li"},"request_randomness"),", which will assign an oracle to our VRF request"),(0,o.kt)("li",{parentName:"ul"},"oracle watches the chain then responds to our VRF request with the proof\ncalculated using its secret key"),(0,o.kt)("li",{parentName:"ul"},"oracle executes the 276 instructions to verify the VRF proof"),(0,o.kt)("li",{parentName:"ul"},"when VRF proof is verified, the Switchboard program will invoke our client\nprogram's ",(0,o.kt)("inlineCode",{parentName:"li"},"consume_randomness")," instruction"),(0,o.kt)("li",{parentName:"ul"},"Done!")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"View the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/switchboard-xyz/sbv2-solana/tree/main/programs/anchor-vrf-parser"},"anchor-vrf-parser"),"\nexample on Github.")),(0,o.kt)("h2",{id:"1-anchor-init"},"1. Anchor Init"),(0,o.kt)("p",null,"Let's create a new anchor project and setup the directory"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor init vrf-client\ncd vrf-client\nrm -rf app migrations\n")),(0,o.kt)("p",null,"We'll need to update our program ID to our unique deploy keypair. First build\nthe example program to generate the target directory and deploy keypair. Then\ngrab your program ID and update ",(0,o.kt)("inlineCode",{parentName:"p"},"Anchor.toml")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ anchor build\n$ solana-keygen pubkey target/deploy/vrf_client-keypair.json\nEmPZGD34KDCtdwtqJU5VGoqidDQLyW1eyBXvj4yb2W9i\n")),(0,o.kt)("h2",{id:"2-add-dependencies"},"2. Add Dependencies"),(0,o.kt)("p",null,"We'll be using the switchboard CLI. Install it if you haven't already"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm i -g @switchboard-xyz/cli@^2\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/Cargo.toml")," add the following lines"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nanchor-lang = "~0.27.0"\nanchor-spl = "~0.27.0"\nsolana-program = "~1.14.0"\nswitchboard-v2 = "^0.1.23"\nbytemuck = "1.7.2"\n')),(0,o.kt)("p",null,"Install npm packages"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add \\\n        @switchboard-xyz/solana.js^2.1.4 \\\n        @solana/web3.js \\\n        @coral-xyz/anchor@^0.27.0 \\\n        @coral-xyz/borsh^0.27.0 \\\n        bn.js\nyarn add -D \\\n        @switchboard-xyz/cli@^2 \\\n        @switchboard-xyz/oracle \\\n        anchor-client-gen \\\n        @types/bn.js \\\n        shx\n")),(0,o.kt)("h2",{id:"3-initial-program-scaffolding"},"3. Initial Program Scaffolding"),(0,o.kt)("p",null,"This program will be fairly simple and contain only 3 instructions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"init_client")," will initialize an on-chain program derived account to hold\nour state and VRF result"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"request_randomness")," will make a cross program invocation to Switchboard to\nrequest an oracle to fulfill a VRF update request"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"consume_randomness")," will be a cross program invocation from Switchboard\ninto our VRF client program to let us know a new randomness value was produced\nand verified successfully")),(0,o.kt)("p",null,"Each instruction will be contained in its own module in\n",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/actions")," to breakup any program logic. Each action will\ncontain a validate function to do any validation before calling actuate which\ncontains the core instruction logic. In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs"),", we'll\nmap each action to our program struct so anchor knows each instructions entry\npoint."),(0,o.kt)("p",null,"First start by creating the folder structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir -p programs/vrf-client/src/actions\ntouch programs/vrf-client/src/actions/mod.rs programs/vrf-client/src/actions/init_client.rs\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/mod.rs"),", import the init_client module which\nwill house our first instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod init_client;\npub use init_client::*;\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/init_client.rs"),", add the initial instruction\nstructs which we will populate later."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::*;\n\n#[derive(Accounts)]\n#[instruction(params: InitClientParams)]\npub struct InitClient {}\n\n#[derive(Clone, AnchorSerialize, AnchorDeserialize)]\npub struct InitClientParams {}\n\nimpl InitClient {\n    pub fn validate(&self, _ctx: &Context<Self>, params: &InitClientParams) -> Result<()> {\n        msg!("init_client validate");\n        Ok(())\n    }\n\n    pub fn actuate(ctx: &Context<Self>, params: &InitClientParams) -> Result<()> {\n        msg!("init_client actuate");\n\n        Ok(())\n    }\n}\n')),(0,o.kt)("p",null,"Then we'll map this instruction in ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use anchor_lang::prelude::*;\n\npub mod actions;\npub use actions::*;\n\npub use anchor_lang::solana_program::clock;\npub use anchor_spl::token::{Token, TokenAccount};\npub use switchboard_v2::{\n    OracleQueueAccountData, PermissionAccountData, SbState, VrfAccountData, VrfRequestRandomness,\n};\n\ndeclare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");\n\n#[program]\npub mod vrf_client {\n    use super::*;\n\n    #[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn init_client(ctx: Context<InitClient>, params: InitClientParams) -> Result<()> {\n        InitClient::actuate(&ctx, &params)\n    }\n}\n')),(0,o.kt)("p",null,"And finally we'll fix up and run the test. Update ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/vrf-client.ts")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import "mocha";\n\nimport * as anchor from "@coral-xyz/anchor";\nimport { AnchorProvider } from "@coral-xyz/anchor";\nimport * as sbv2 from "@switchboard-xyz/solana.js";\nimport { VrfClient } from "../target/types/vrf_client";\nimport { assert } from "chai";\nimport { BN } from "bn.js";\n\ndescribe("vrf-client", () => {\n  // Configure the client to use the local cluster.\n  const provider = AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  const program: anchor.Program<VrfClient> = anchor.workspace.VrfClient;\n  const payer = (provider.wallet as sbv2.AnchorWallet).payer;\n\n  it("init_client", async () => {\n    // Add your test here.\n    const tx = await program.methods.initClient({}).rpc();\n    console.log("init_client transaction signature", tx);\n  });\n});\n')),(0,o.kt)("p",null,"Build the program and run the test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ anchor test\n\n  vrf-client\ninit_client transaction signature Db5TfiWLT269ehpEXgT4dQntjGxj4PytYWPg1XCANcDGqseedGmqq4S5xkQ3RWkHx1FsdmpxSP1p5HKUYomiqAJ\n    \u2714 init_client (499ms)\n\n\n  1 passing (501ms)\n")),(0,o.kt)("h2",{id:"4-setup-switchboard-environment"},"4. Setup Switchboard Environment"),(0,o.kt)("p",null,"In your Anchor.toml, add the following to clone the switchboard program and\ncontext when using a localnet environment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[test]\nstartup_wait = 10000\n\n[test.validator]\nurl = "https://api.devnet.solana.com"\n\n[[test.validator.clone]] # sbv2 devnet programID\naddress = "SW1TCH7qEPTdLsDHRgPuMQjbQxKdH2aBStViMFnt64f"\n\n[[test.validator.clone]] # sbv2 devnet IDL\naddress = "Fi8vncGpNKbq62gPo56G4toCehWNy77GgqGkTaAF5Lkk"\n\n[[test.validator.clone]] # sbv2 devnet SbState\naddress = "CyZuD7RPDcrqCGbNvLCyqk6Py9cEZTKmNKujfPi3ynDd"\n\n[[test.validator.clone]] # sbv2 devnet tokenVault\naddress = "7hkp1xfPBcD2t1vZMoWWQPzipHVcXeLAAaiGXdPSfDie"\n\n')),(0,o.kt)("p",null,"Now let's update our test and print out our oracle queue to the console."),(0,o.kt)("p",null,"Open ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/vrf-client.ts")," and add the following before hook. This will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Create a new Switchboard queue and oracle"),(0,o.kt)("li",{parentName:"ul"},"Startup a Docker container in the background with your newly created oracle"),(0,o.kt)("li",{parentName:"ul"},"Wait for the Docker container to signal readiness")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import "mocha";\n\nimport * as anchor from "@coral-xyz/anchor";\nimport { AnchorProvider } from "@coral-xyz/anchor";\nimport * as sbv2 from "@switchboard-xyz/solana.js";\nimport { VrfClient } from "../target/types/vrf_client";\nimport { assert } from "chai";\nimport { BN } from "bn.js";\nimport { PublicKey } from "@solana/web3.js";\nimport { NodeOracle } from "@switchboard-xyz/oracle";\n\ndescribe("vrf-client", () => {\n  const provider = AnchorProvider.env();\n  anchor.setProvider(provider);\n\n  const program: anchor.Program<VrfClient> = anchor.workspace.VrfClient;\n  const payer = (provider.wallet as sbv2.AnchorWallet).payer;\n\n  const vrfSecret = anchor.web3.Keypair.generate();\n  console.log(`VRF Account: ${vrfSecret.publicKey}`);\n\n  const [vrfClientKey] = PublicKey.findProgramAddressSync(\n    [Buffer.from("CLIENTSEED"), vrfSecret.publicKey.toBytes()],\n    program.programId\n  );\n  console.log(`VRF Client: ${vrfClientKey}`);\n\n  const vrfIxCoder = new anchor.BorshInstructionCoder(program.idl);\n  const vrfClientCallback: sbv2.Callback = {\n    programId: program.programId,\n    accounts: [\n      // ensure all accounts in consumeRandomness are populated\n      { pubkey: vrfClientKey, isSigner: false, isWritable: true },\n      { pubkey: vrfSecret.publicKey, isSigner: false, isWritable: false },\n    ],\n    ixData: vrfIxCoder.encode("consumeRandomness", ""), // pass any params for instruction here\n  };\n\n  let switchboard: sbv2.SwitchboardTestContext;\n  let oracle: NodeOracle;\n  let vrfAccount: sbv2.VrfAccount;\n\n  before(async () => {\n    switchboard = await sbv2.SwitchboardTestContext.loadFromProvider(provider, {\n      // You can provide a keypair to so the PDA schemes dont change between test runs\n      name: "Test Queue",\n      keypair: sbv2.SwitchboardTestContextV2.loadKeypair(\n        "~/.keypairs/queue.json"\n      ),\n      queueSize: 10,\n      reward: 0,\n      minStake: 0,\n      oracleTimeout: 900,\n      unpermissionedFeeds: true,\n      unpermissionedVrf: true,\n      enableBufferRelayers: true,\n      oracle: {\n        name: "Test Oracle",\n        enable: true,\n        stakingWalletKeypair: sbv2.SwitchboardTestContextV2.loadKeypair(\n          "~/.keypairs/oracleWallet.json"\n        ),\n      },\n    });\n\n    oracle = await NodeOracle.fromReleaseChannel({\n      chain: "solana",\n      releaseChannel: "testnet",\n      network: "localnet", // disables production capabilities like monitoring and alerts\n      rpcUrl: switchboard.program.connection.rpcEndpoint,\n      oracleKey: switchboard.oracle.publicKey.toBase58(),\n      secretPath: switchboard.walletPath,\n      silent: false, // set to true to suppress oracle logs in the console\n      envVariables: {\n        VERBOSE: "1",\n        DEBUG: "1",\n        DISABLE_NONCE_QUEUE: "1",\n        DISABLE_METRICS: "1",\n      },\n    });\n\n    await oracle.startAndAwait();\n  });\n\n  after(async () => {\n    oracle?.stop();\n  });\n\n  it("init_client", async () => {\n    const tx = await program.methods.initClient({}).rpc();\n    console.log("init_client transaction signature", tx);\n  });\n});\n')),(0,o.kt)("p",null,"Then run the test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor test\n")),(0,o.kt)("h2",{id:"5-add-init_client-instruction"},"5. Add init_client Instruction"),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs"),", add the seed we'll use to derive our client\nPDA pubkey, the VrfClientState struct, and some errors we'll be using."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'const STATE_SEED: &[u8] = b"CLIENTSEED";\n\n#[repr(packed)]\n#[account(zero_copy(unsafe))]\n#[derive(Default)]\npub struct VrfClientState {\n    pub bump: u8,\n    pub max_result: u64,\n    pub result_buffer: [u8; 32],\n    pub result: u128,\n    pub timestamp: i64,\n    pub vrf: Pubkey,\n}\n')),(0,o.kt)("p",null,"add some errors we'll use"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[error_code]\n#[derive(Eq, PartialEq)]\npub enum VrfClientErrorCode {\n    #[msg("Switchboard VRF Account\'s authority should be set to the client\'s state pubkey")]\n    InvalidVrfAuthorityError,\n    #[msg("The max result must not exceed u64")]\n    MaxResultExceedsMaximum,\n}\n')),(0,o.kt)("p",null,"then add an AnchorEvent we'll trigger when a new VRF Client is created"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[event]\npub struct VrfClientCreated {\n    pub vrf_client: Pubkey,\n    pub max_result: u64,\n    pub timestamp: i64,\n}\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/init_client.rs"),", add the following code for\nthe init_client instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::*;\n\n#[derive(Accounts)]\n#[instruction(params: InitClientParams)]\npub struct InitClient<'info> {\n    #[account(\n        init,\n        seeds = [\n            STATE_SEED,\n            vrf.key().as_ref()\n        ],\n        payer = payer,\n        space = 8 + std::mem::size_of::<VrfClientState>(),\n        bump,\n    )]\n    pub state: AccountLoader<'info, VrfClientState>,\n    #[account(\n        constraint = vrf.load()?.authority == state.key() @ VrfClientErrorCode::InvalidVrfAuthorityError\n    )]\n    pub vrf: AccountLoader<'info, VrfAccountData>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Clone, AnchorSerialize, AnchorDeserialize)]\npub struct InitClientParams {\n    pub max_result: u64,\n}\n\nimpl InitClient<'_>  {\n    pub fn validate(&self, _ctx: &Context<Self>, params: &InitClientParams) -> Result<()> {\n        msg!(\"init_client validate\");\n        if params.max_result > 1337 {\n            return Err(error!(VrfClientErrorCode::MaxResultExceedsMaximum));\n        }\n\n        Ok(())\n    }\n\n    pub fn actuate(ctx: &Context<Self>, params: &InitClientParams) -> Result<()> {\n        msg!(\"init_client actuate\");\n\n        let mut state = ctx.accounts.state.load_init()?;\n        *state = VrfClientState::default();\n        state.bump = ctx.bumps.get(\"state\").unwrap().clone();\n        state.vrf = ctx.accounts.vrf.key();\n\n        if params.max_result == 0 {\n            state.max_result = 1337;\n        } else {\n            state.max_result = params.max_result;\n        }\n\n        emit!(VrfClientCreated{\n            vrf_client: ctx.accounts.state.key(),\n            max_result: params.max_result,\n            timestamp: clock::Clock::get().unwrap().unix_timestamp\n        });\n\n        Ok(())\n    }\n}\n")),(0,o.kt)("p",null,"Then update the init_client test."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'it("init_client", async () => {\n  const queue = await switchboard.queue.loadData();\n\n  // Create Switchboard VRF and Permission account\n  [vrfAccount] = await switchboard.queue.createVrf({\n    callback: vrfClientCallback,\n    authority: vrfClientKey, // vrf authority\n    vrfKeypair: vrfSecret,\n    enable: !queue.unpermissionedVrfEnabled, // only set permissions if required\n  });\n\n  console.log(`Created VRF Account: ${vrfAccount.publicKey}`);\n\n  // Create VRF Client account\n  await program.methods\n    .initClient({\n      maxResult: new anchor.BN(1337),\n    })\n    .accounts({\n      state: vrfClientKey,\n      vrf: vrfAccount.publicKey,\n      payer: payer.publicKey,\n      systemProgram: anchor.web3.SystemProgram.programId,\n    })\n    .rpc();\n  console.log(`Created VrfClient Account: ${vrfClientKey}`);\n});\n')),(0,o.kt)("p",null,"Now run the test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor test\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Optionally, add ",(0,o.kt)("inlineCode",{parentName:"em"},"-s")," to suppress the Switchboard oracle logs")),(0,o.kt)("h2",{id:"6-add-request-randomness-instruction"},"6. Add Request Randomness Instruction"),(0,o.kt)("p",null,"We will now request randomness for our VRF Account that is controlled by our\nclient program. We will make a cross program invocation (CPI) into the\nSwitchboard program. The Switchboard program will validate the request then\nassign an oracle to fulfill the randomness request. The oracle is constantly\nwatching the chain for oracle assignment, and when assigned, will calculate the\nVRF result using the VRF Account's public key and the recent blockhash."),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs"),", add the mapping for our request_randomness\naction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},"#[program]\npub mod vrf_client {\n    use super::*;\n\n    #[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn init_client(ctx: Context<InitClient>, params: InitClientParams) -> Result<()> {\n        InitClient::actuate(&ctx, &params)\n    }\n\n+    #[access_control(ctx.accounts.validate(&ctx, &params))]\n+    pub fn request_randomness(\n+        ctx: Context<RequestRandomness>,\n+        params: RequestRandomnessParams,\n+    ) -> Result<()> {\n+        RequestRandomness::actuate(&ctx, &params)\n+    }\n}\n")),(0,o.kt)("p",null,"add some errors we'll use to validate the instruction"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'#[error_code]\n#[derive(Eq, PartialEq)]\npub enum VrfClientErrorCode {\n    #[msg("Switchboard VRF Account\'s authority should be set to the client\'s state pubkey")]\n    InvalidVrfAuthorityError,\n    #[msg("The max result must not exceed u64")]\n    MaxResultExceedsMaximum,\n+    #[msg("Invalid VRF account provided.")]\n+    InvalidVrfAccount,\n+    #[msg("Not a valid Switchboard account")]\n+    InvalidSwitchboardAccount,\n}\n\n')),(0,o.kt)("p",null,"add an event we'll trigger when a VRF Client successfully requests randomness\nfrom a Switchboard queue"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[event]\npub struct RandomnessRequested {\n    pub vrf_client: Pubkey,\n    pub max_result: u64,\n    pub timestamp: i64,\n}\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/mod.rs"),", add the exports"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod request_randomness;\npub use request_randomness::*;\n")),(0,o.kt)("p",null,"Add the request_randomness instruction in\n",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/request_randomness.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use crate::*;\n\n#[derive(Accounts)]\n#[instruction(params: RequestRandomnessParams)] // rpc parameters hint\npub struct RequestRandomness<'info> {\n    #[account(\n        mut,\n        seeds = [\n            STATE_SEED,\n            vrf.key().as_ref(),\n        ],\n        bump = state.load()?.bump,\n        has_one = vrf @ VrfClientErrorCode::InvalidVrfAccount\n    )]\n    pub state: AccountLoader<'info, VrfClientState>,\n\n    // SWITCHBOARD ACCOUNTS\n    #[account(mut,\n        has_one = escrow\n    )]\n    pub vrf: AccountLoader<'info, VrfAccountData>,\n    #[account(mut,\n        has_one = data_buffer\n    )]\n    pub oracle_queue: AccountLoader<'info, OracleQueueAccountData>,\n    /// CHECK:\n    #[account(mut,\n        constraint =\n            oracle_queue.load()?.authority == queue_authority.key()\n    )]\n    pub queue_authority: UncheckedAccount<'info>,\n    /// CHECK\n    #[account(mut)]\n    pub data_buffer: AccountInfo<'info>,\n    #[account(mut)]\n    pub permission: AccountLoader<'info, PermissionAccountData>,\n    #[account(mut,\n        constraint =\n            escrow.owner == program_state.key()\n            && escrow.mint == program_state.load()?.token_mint\n    )]\n    pub escrow: Account<'info, TokenAccount>,\n    #[account(mut)]\n    pub program_state: AccountLoader<'info, SbState>,\n    /// CHECK:\n    #[account(\n        address = *vrf.to_account_info().owner,\n        constraint = switchboard_program.executable == true\n    )]\n    pub switchboard_program: AccountInfo<'info>,\n\n    // PAYER ACCOUNTS\n    #[account(mut,\n        constraint =\n            payer_wallet.owner == payer_authority.key()\n            && escrow.mint == program_state.load()?.token_mint\n    )]\n    pub payer_wallet: Account<'info, TokenAccount>,\n    /// CHECK:\n    #[account(signer)]\n    pub payer_authority: AccountInfo<'info>,\n\n    // SYSTEM ACCOUNTS\n    /// CHECK:\n    #[account(address = solana_program::sysvar::recent_blockhashes::ID)]\n    pub recent_blockhashes: AccountInfo<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[derive(Clone, AnchorSerialize, AnchorDeserialize)]\npub struct RequestRandomnessParams {\n    pub permission_bump: u8,\n    pub switchboard_state_bump: u8,\n}\n\nimpl RequestRandomness<'_> {\n    pub fn validate(&self, _ctx: &Context<Self>, _params: &RequestRandomnessParams) -> Result<()> {\n        Ok(())\n    }\n\n    pub fn actuate(ctx: &Context<Self>, params: &RequestRandomnessParams) -> Result<()> {\n        let client_state = ctx.accounts.state.load()?;\n        let bump = client_state.bump.clone();\n        let max_result = client_state.max_result;\n        drop(client_state);\n\n        let switchboard_program = ctx.accounts.switchboard_program.to_account_info();\n\n        let vrf_request_randomness = VrfRequestRandomness {\n            authority: ctx.accounts.state.to_account_info(),\n            vrf: ctx.accounts.vrf.to_account_info(),\n            oracle_queue: ctx.accounts.oracle_queue.to_account_info(),\n            queue_authority: ctx.accounts.queue_authority.to_account_info(),\n            data_buffer: ctx.accounts.data_buffer.to_account_info(),\n            permission: ctx.accounts.permission.to_account_info(),\n            escrow: ctx.accounts.escrow.clone(),\n            payer_wallet: ctx.accounts.payer_wallet.clone(),\n            payer_authority: ctx.accounts.payer_authority.to_account_info(),\n            recent_blockhashes: ctx.accounts.recent_blockhashes.to_account_info(),\n            program_state: ctx.accounts.program_state.to_account_info(),\n            token_program: ctx.accounts.token_program.to_account_info(),\n        };\n\n        let vrf_key = ctx.accounts.vrf.key();\n        let state_seeds: &[&[&[u8]]] = &[&[\n            &STATE_SEED,\n            vrf_key.as_ref(),\n            &[bump],\n        ]];\n\n        msg!(\"requesting randomness\");\n        vrf_request_randomness.invoke_signed(\n            switchboard_program,\n            params.switchboard_state_bump,\n            params.permission_bump,\n            state_seeds,\n        )?;\n\n        let mut client_state = ctx.accounts.state.load_mut()?;\n        client_state.result = 0;\n\n        emit!(RandomnessRequested{\n            vrf_client: ctx.accounts.state.key(),\n            max_result: max_result,\n            timestamp: clock::Clock::get().unwrap().unix_timestamp\n        });\n\n        msg!(\"randomness requested successfully\");\n        Ok(())\n    }\n}\n")),(0,o.kt)("p",null,"Now let's add some client tests in ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/vrf-client.ts")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'it("request_randomness", async () => {\n  const queue = await switchboard.queue.loadData();\n  const vrf = await vrfAccount.loadData();\n\n  // derive the existing VRF permission account using the seeds\n  const [permissionAccount, permissionBump] = sbv2.PermissionAccount.fromSeed(\n    switchboard.program,\n    queue.authority,\n    switchboard.queue.publicKey,\n    vrfAccount.publicKey\n  );\n\n  const [payerTokenWallet] =\n    await switchboard.program.mint.getOrCreateWrappedUser(\n      switchboard.program.walletPubkey,\n      { fundUpTo: 0.002 }\n    );\n\n  // Request randomness\n  await program.methods\n    .requestRandomness({\n      switchboardStateBump: switchboard.program.programState.bump,\n      permissionBump,\n    })\n    .accounts({\n      state: vrfClientKey,\n      vrf: vrfAccount.publicKey,\n      oracleQueue: switchboard.queue.publicKey,\n      queueAuthority: queue.authority,\n      dataBuffer: queue.dataBuffer,\n      permission: permissionAccount.publicKey,\n      escrow: vrf.escrow,\n      programState: switchboard.program.programState.publicKey,\n      switchboardProgram: switchboard.program.programId,\n      payerWallet: payerTokenWallet,\n      payerAuthority: payer.publicKey,\n      recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n      tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,\n    })\n    .rpc();\n});\n')),(0,o.kt)("p",null,"Then run the test"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor test\n")),(0,o.kt)("h2",{id:"7-add-consume-randomness-instruction"},"7. Add Consume Randomness Instruction"),(0,o.kt)("p",null,"Right now our program can request randomness but we never configured the\ncallback into our program so we have no way to know when the randomness value\nwas produced. So we will need to add a new instruction that the Switchboard\noracle will call in order to update our client's state."),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/lib.rs"),", add the mapping for our consume_randomness\naction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},"#[program]\npub mod vrf_client {\n    use super::*;\n\n    #[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn init_client(ctx: Context<initClient>, params: initClientParams) -> Result<()> {\n        initClient::actuate(&ctx, &params)\n    }\n\n    #[access_control(ctx.accounts.validate(&ctx, &params))]\n    pub fn request_randomness(\n        ctx: Context<RequestRandomness>,\n        params: RequestRandomnessParams,\n    ) -> Result<()> {\n        RequestRandomness::actuate(&ctx, &params)\n    }\n\n+    #[access_control(ctx.accounts.validate(&ctx, &params))]\n+    pub fn consume_randomness(\n+        ctx: Context<ConsumeRandomness>,\n+        params: ConsumeRandomnessParams,\n+    ) -> Result<()> {\n+        ConsumeRandomness::actuate(&ctx, &params)\n+    }\n}\n")),(0,o.kt)("p",null,"add an event we'll trigger when a VRF Client successfully consumes randomness\nfrom a Switchboard queue"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[event]\npub struct VrfClientUpdated {\n    pub vrf_client: Pubkey,\n    pub max_result: u64,\n    pub result_buffer: [u8; 32],\n    pub result: u128,\n    pub timestamp: i64,\n}\n")),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/mod.rs"),", add the exports"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub mod consume_randomness;\npub use consume_randomness::*;\n")),(0,o.kt)("p",null,"Add the consume_randomness instruction in\n",(0,o.kt)("inlineCode",{parentName:"p"},"programs/vrf-client/src/actions/consume_randomness.rs")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::*;\n\n#[derive(Accounts)]\n#[instruction(params: ConsumeRandomnessParams)] // rpc parameters hint\npub struct ConsumeRandomness<\'info> {\n    #[account(\n        mut,\n        seeds = [\n            STATE_SEED,\n            vrf.key().as_ref(),\n        ],\n        bump = state.load()?.bump,\n        has_one = vrf @ VrfClientErrorCode::InvalidVrfAccount\n    )]\n    pub state: AccountLoader<\'info, VrfClientState>,\n    pub vrf: AccountLoader<\'info, VrfAccountData>,\n}\n\n#[derive(Clone, AnchorSerialize, AnchorDeserialize)]\npub struct ConsumeRandomnessParams {}\n\nimpl ConsumeRandomness<\'_> {\n    pub fn validate(&self, _ctx: &Context<Self>, _params: &ConsumeRandomnessParams) -> Result<()> {\n        Ok(())\n    }\n\n    pub fn actuate(ctx: &Context<Self>, _params: &ConsumeRandomnessParams) -> Result<()> {\n        let vrf = ctx.accounts.vrf.load()?;\n        let result_buffer = vrf.get_result()?;\n        if result_buffer == [0u8; 32] {\n            msg!("vrf buffer empty");\n            return Ok(());\n        }\n\n        let state = &mut ctx.accounts.state.load_mut()?;\n        let max_result = state.max_result;\n        if result_buffer == state.result_buffer {\n            msg!("result_buffer unchanged");\n            return Ok(());\n        }\n\n        msg!("Result buffer is {:?}", result_buffer);\n        let value: &[u128] = bytemuck::cast_slice(&result_buffer[..]);\n        msg!("u128 buffer {:?}", value);\n        let result = value[0] % max_result as u128 + 1;\n        msg!("Current VRF Value [1 - {}) = {}!", max_result, result);\n\n        if state.result != result {\n            state.result_buffer = result_buffer;\n            state.result = result;\n            state.timestamp = clock::Clock::get().unwrap().unix_timestamp;\n\n            emit!(VrfClientUpdated {\n                vrf_client: ctx.accounts.state.key(),\n                max_result: state.max_result,\n                result: state.result,\n                result_buffer: result_buffer,\n                timestamp: state.timestamp,\n            });\n        }\n\n        Ok(())\n    }\n}\n')),(0,o.kt)("p",null,"Ok, now we need to update our tests. Let's look at ",(0,o.kt)("inlineCode",{parentName:"p"},"tests/vrf-client.ts"),". When\nwe created our VrfAccount we didn't define a callback so our oracle will never\nlet our program know when a new value is available. You could watch the chain\nand call the consume_randomness instruction yourself but that is extra overhead\nand complexity."),(0,o.kt)("p",null,"Instead we will define a callback so the oracle will call our program each time\na new value is accepted. The consume_randomness instruction includes two\naccounts, our client and the VRF Account, and has no parameters. You may be\nthinking the ixData will be empty but Anchor adds a unique 8 byte discriminator\nto all instructions (and accounts) which is a hash of the instruction name. This\nhelps map the instruction to your programs interface."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'const [vrfAccount] = await switchboard.queue.createVrf({\n    vrfKeypair,\n    callback: {\n        programId: program.programId,\n-       accounts: [],\n+       accounts: [\n+           { pubkey: vrfClientKey, isSigner: false, isWritable: true },\n+           { pubkey: vrfKeypair.publicKey, isSigner: false, isWritable: false },\n+       ],\n-       ixData: Buffer.from(""),\n+       ixData: new anchor.BorshInstructionCoder(program.idl).encode(\n+           "consumeRandomness",\n+           ""\n+       ),\n    },\n    enable: true,\n});\n')),(0,o.kt)("p",null,"Now let's add some logic to await the randomness result from the oracle. This\nfunction will invoke our programs request randomness instruction then open a\nwebsocket and await the result. If the result is not populated in 45s then it\nwill throw an error."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'it("request_randomness", async () => {\n  // ... request randomness\n\n  const result = await vrfAccount.nextResult(\n    new anchor.BN(vrf.counter.toNumber() + 1),\n    45_000\n  );\n  if (!result.success) {\n    throw new Error(`Failed to get VRF Result: ${result.status}`);\n  }\n\n  const vrfClientState = await program.account.vrfClientState.fetch(\n    vrfClientKey\n  );\n  console.log(`VrfClient Result: ${vrfClientState.result.toString(10)}`);\n\n  const callbackTxnMeta = await vrfAccount.getCallbackTransactions();\n  console.log(\n    JSON.stringify(\n      callbackTxnMeta.map((tx) => tx.meta.logMessages),\n      undefined,\n      2\n    )\n  );\n\n  assert(!vrfClientState.result.eq(new BN(0)), "Vrf Client holds no result");\n});\n')),(0,o.kt)("p",null,"And finally run the test!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'$ anchor test\n\nVRF Account: BJe3Y8WQUnT4wx9owBSxwRTuXFHk3deJAMFVPzFTWAxd\nVRF Client: 8tNNmjT8QxRabWeQKSqTXtR296h8fg8p8rDvAnYKsssW\n\n\n  vrf-client\nStarting Switchboard oracle ...\nCreated VRF Account: BJe3Y8WQUnT4wx9owBSxwRTuXFHk3deJAMFVPzFTWAxd\nCreated VrfClient Account: 8tNNmjT8QxRabWeQKSqTXtR296h8fg8p8rDvAnYKsssW\n    \u2714 init_client (868ms)\n\nVrfClient Result: 423\n[\n  [\n    "Program ComputeBudget111111111111111111111111111111 invoke [1]",\n    "Program ComputeBudget111111111111111111111111111111 success",\n    "Program ComputeBudget111111111111111111111111111111 invoke [1]",\n    "Program ComputeBudget111111111111111111111111111111 success",\n    "Program 2TfB33aLaneQb5TNVwyDz3jSZXS6jdW2ARw1Dgf84XCG invoke [1]",\n    "Program log: Instruction: VrfProveAndVerify",\n    "Program log: Invoking callback",\n    "Program EmPZGD34KDCtdwtqJU5VGoqidDQLyW1eyBXvj4yb2W9i invoke [2]",\n    "Program log: Instruction: ConsumeRandomness",\n    "Program log: Result buffer is [154, 219, 184, 150, 38, 3, 191, 10, 24, 94, 122, 191, 243, 220, 46, 3, 127, 16, 168, 132, 253, 154, 220, 201, 165, 215, 50, 80, 44, 155, 227, 59]",\n    "Program log: u128 buffer [4231011084663214195166609165078027162, 79606250422545424453288202565814063231]",\n    "Program log: Current VRF Value [1 - 1337) = 423!",\n    "Program data: V8IkGhLydDZ1KplU2NCJUISD3i6LBt01IwAMyruAYBhFe04y+lhyiTkFAAAAAAAAmtu4liYDvwoYXnq/89wuA38QqIT9mtzJpdcyUCyb4zunAQAAAAAAAAAAAAAAAAAAsmbQYwAAAAA=",\n    "Program EmPZGD34KDCtdwtqJU5VGoqidDQLyW1eyBXvj4yb2W9i consumed 24439 of 1386272 compute units",\n    "Program EmPZGD34KDCtdwtqJU5VGoqidDQLyW1eyBXvj4yb2W9i success",\n    "Program data: KT1kCMGFQ4WZGaDlpbqimoe3KXzhbQ4vGtkw9W7vNVyMmAaYkEE3BlCuBj8iwJHMZ46bwLeQsva1G43tyWLKwk8Gi9F77RPrAAAAAAAAAAA=",\n    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]",\n    "Program log: Instruction: Transfer",\n    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 4785 of 1358285 compute units",\n    "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success",\n    "Program 2TfB33aLaneQb5TNVwyDz3jSZXS6jdW2ARw1Dgf84XCG consumed 47533 of 1400000 compute units",\n    "Program 2TfB33aLaneQb5TNVwyDz3jSZXS6jdW2ARw1Dgf84XCG success"\n  ]\n]\n    \u2714 request_randomness (4340ms)\n\n\n  2 passing (27s)\n\n\u2728  Done in 28.30s.\n')),(0,o.kt)("p",null,"And just like that you have integrated Switchboard's VRF into your very own\nAnchor program!"),(0,o.kt)("h2",{id:"8-deployment-instructions"},"8. Deployment Instructions"),(0,o.kt)("h3",{id:"deploying-to-devnet"},"Deploying to Devnet"),(0,o.kt)("p",null,"Update the cluster in ",(0,o.kt)("inlineCode",{parentName:"p"},"Anchor.toml")," to devnet"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'[provider]\n- cluster = "localnet"\n+ cluster = "devnet"\nwallet = "~/.config/solana/id.json"\n')),(0,o.kt)("p",null,"In our test we use the SwitchboardTestContext to load our personal Switchboard\nenvironment. If you are deploying to devnet you may not want to run your own\noracles and instead can opt in to using the Switchboard DAO queues. When\ncreating a VRF Account, use Switchboard's devnet permissionless queue located at\n",(0,o.kt)("inlineCode",{parentName:"p"},"uPeRMdfPmrPqgRWSrjAnAkH78RqAhe5kXoW6vBYRqFX"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'describe("vrf-client", () => {\n     ixData: vrfIxCoder.encode("consumeRandomness", ""), // pass any params for instruction here\n   };\n\n-  let switchboard: sbv2.SwitchboardTestContext;\n+  let switchboard: {\n+    program: sbv2.SwitchboardProgram;\n+    queue: sbv2.QueueAccount;\n+  };\n   let oracle: NodeOracle;\n   let vrfAccount: sbv2.VrfAccount;\n\n   before(async () => {\n-    switchboard = await sbv2.SwitchboardTestContext.loadFromProvider(\n-      provider,\n-      {\n-        // You can provide a keypair to so the PDA schemes dont change between test runs\n-        name: "Test Queue",\n-        keypair: sbv2.SwitchboardTestContext.loadKeypair(\n-          "~/.keypairs/queue.json"\n-        ),\n-        queueSize: 10,\n-        reward: 0,\n-        minStake: 0,\n-        oracleTimeout: 900,\n-        unpermissionedFeeds: true,\n-        unpermissionedVrf: true,\n-        enableBufferRelayers: true,\n-        oracle: {\n-          name: "Test Oracle",\n-          enable: true,\n-          stakingWalletKeypair: sbv2.SwitchboardTestContext.loadKeypair(\n-            "~/.keypairs/oracleWallet.json"\n-          ),\n-        },\n-      }\n+    const switchboardProgram = await sbv2.SwitchboardProgram.fromProvider(\n+      provider\n     );\n-\n-    oracle = await NodeOracle.fromReleaseChannel({\n-      chain: "solana",\n-      releaseChannel: "testnet",\n-      network: "localnet", // disables production capabilities like monitoring and alerts\n-      rpcUrl: switchboard.program.connection.rpcEndpoint,\n-      oracleKey: switchboard.oracle.publicKey.toBase58(),\n-      secretPath: switchboard.walletPath,\n-      silent: false, // set to true to suppress oracle logs in the console\n-      envVariables: {\n-        VERBOSE: "1",\n-        DEBUG: "1",\n-        DISABLE_NONCE_QUEUE: "1",\n-        DISABLE_METRICS: "1",\n-      },\n-    });\n-\n-    await oracle.startAndAwait();\n-  });\n-\n-  after(async () => {\n-    oracle?.stop();\n+    const [queueAccount, queue] = await sbv2.QueueAccount.load(\n+      switchboardProgram,\n+      "uPeRMdfPmrPqgRWSrjAnAkH78RqAhe5kXoW6vBYRqFX"\n+    );\n+    switchboard = { program: switchboardProgram, queue: queueAccount };\n   });\n\n   it("init_client", async () => {\n\n')),(0,o.kt)("p",null,"Run the following command to deploy your program to devnet"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor deploy\n")),(0,o.kt)("h3",{id:"deploying-to-mainnet"},"Deploying to Mainnet"),(0,o.kt)("p",null,"Update the cluster in ",(0,o.kt)("inlineCode",{parentName:"p"},"Anchor.toml")," to mainnet"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'[provider]\n- cluster = "localnet"\n+ cluster = "mainnet"\nwallet = "~/.config/solana/id.json"\n')),(0,o.kt)("p",null,"Like above, you will want to create VRF Accounts for a mainnet queue. You may\nuse Switchboard's mainnet permissionless queue located at\n",(0,o.kt)("inlineCode",{parentName:"p"},"3HBb2DQqDfuMdzWxNk1Eo9RTMkFYmuEAd32RiLKn9pAn"),"."),(0,o.kt)("p",null,"Run the following command to deploy your program to mainnet"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"anchor deploy\n")))}g.isMDXComponent=!0}}]);