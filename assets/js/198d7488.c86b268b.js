"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9253],{54852:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var a=n(49231);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),i=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=i(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),d=i(n),p=r,h=d["".concat(c,".").concat(p)]||d[p]||m[p]||o;return n?a.createElement(h,s(s({ref:t},l),{},{components:n})):a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=p;var u={};for(var c in t)hasOwnProperty.call(t,c)&&(u[c]=t[c]);u.originalType=e,u[d]="string"==typeof e?e:r,s[1]=u;for(var i=2;i<o;i++)s[i]=n[i];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},16109:(e,t,n)=>{var a=n(10287);t.Z=void 0;var r=a(n(88706)),o=n(20264),s=(0,r.default)((0,o.jsx)("path",{d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"}),"ContentCopy");t.Z=s},53242:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(49231),r=n(19841);const o={tabItem:"tabItem_B1C6"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,s),hidden:n},t)}},79793:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(95634),r=n(49231),o=n(19841),s=n(49949),u=n(4345),c=n(54162);const i={tabList:"tabList_wB6B",tabItem:"tabItem_i0b_"};function l(e){let{className:t,block:n,selectedValue:u,selectValue:c,tabValues:l}=e;const d=[],{blockElementScrollPositionUntilNextRender:m}=(0,s.o5)(),p=e=>{const t=e.currentTarget,n=d.indexOf(t),a=l[n].value;a!==u&&(m(t),c(a))},h=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},l.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,key:t,ref:e=>d.push(e),onKeyDown:h,onClick:p},s,{className:(0,o.Z)("tabs__item",i.tabItem,s?.className,{"tabs__item--active":u===t})}),n??t)})))}function d(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function m(e){const t=(0,u.Y)(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",i.tabList)},r.createElement(l,(0,a.Z)({},e,t)),r.createElement(d,(0,a.Z)({},e,t)))}function p(e){const t=(0,c.Z)();return r.createElement(m,(0,a.Z)({key:String(t)},e))}},4345:(e,t,n)=>{n.d(t,{Y:()=>m});var a=n(49231),r=n(19409),o=n(18048),s=n(54657),u=n(70583);function c(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function i(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,s.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function l(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:n}=e;const s=(0,r.k6)(),u=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o._X)(u),(0,a.useCallback)((e=>{if(!u)return;const t=new URLSearchParams(s.location.search);t.set(u,e),s.replace({...s.location,search:t.toString()})}),[u,s])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=i(e),[s,c]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!l({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[m,p]=d({queryString:n,groupId:r}),[h,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,u.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),b=(()=>{const e=m??h;return l({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{b&&c(b)}),[b]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!l({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),p(e),f(e)}),[p,f,o]),tabValues:o}}},46441:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(16109),r=n(7179),o=n(73943),s=n(92994),u=n(49231);function c(e){let t={textTransform:"none",color:"var(--ifm-color-primary-light)",fontWeight:800,margin:0};e.sx&&(t={...t,...e.sx});return u.createElement(r.Z,{title:"copy to clipboard","aria-label":"copy to clipboard",arrow:!0},u.createElement(o.Z,{variant:"text",size:"small",startIcon:u.createElement(a.Z,{sx:{fill:"var(--ifm-color-primary-darkest)"},fontSize:"small"}),onClick:()=>{const t=document.createElement("textarea");t.value=e.address,document.body.appendChild(t),t.select(),document.execCommand("copy"),document.body.removeChild(t)}},u.createElement(s.Z,{sx:t,color:"textSecondary"},function(e,t){if(!t||0===t||0===e.length||e.length<t)return e;const n=t,a=Math.floor(e.length/2),r=n%2==0?a-n/2:a-Math.floor(n/2)-1,o=n%2==0?a+n/2:a-Math.floor(n/2);return`${e.slice(0,r)}...${e.slice(o,e.length)}`}(e.address,e.trim))))}},45983:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(63102),r=n(86953),o=n(40862),s=n(49231);const u=e=>{const{colorMode:t}=(0,a.I)(),n=(0,r.Z)("dark"===t&&e.darkImg?e.darkImg:e.img);let u="inherit";e.lightBg&&"dark"!==t&&(u=e.lightBg),e.darkBg&&"dark"===t&&(u=e.darkBg);let c={};return e.sx&&(c={backgroundColor:u,m:"auto",display:"flex",...c,...e.sx}),s.createElement(o.Z,{component:"img",sx:c,src:n})}},24420:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>u,metadata:()=>i,toc:()=>d});var a=n(95634),r=(n(49231),n(54852)),o=(n(45983),n(46441),n(6289),n(49451),n(79793)),s=n(53242);const u={title:"Ex. 02: Randomness Callback",sidebar_position:101,hide_title:!0,slug:"/solana/functions/examples/randomness-callback"},c="Randomness Callback",i={unversionedId:"solana/functions/randomness-callback",id:"solana/functions/randomness-callback",title:"Ex. 02: Randomness Callback",description:'Switchboard Functions can have _"sub-accounts"_ called Function Request Account\'s which allow you to pass',source:"@site/docs/solana/functions/randomness-callback.mdx",sourceDirName:"solana/functions",slug:"/solana/functions/examples/randomness-callback",permalink:"/solana/functions/examples/randomness-callback",draft:!1,tags:[],version:"current",sidebarPosition:101,frontMatter:{title:"Ex. 02: Randomness Callback",sidebar_position:101,hide_title:!0,slug:"/solana/functions/examples/randomness-callback"},sidebar:"gettingStartedSidebar",previous:{title:"Ex. 01: Basic Oracle Example",permalink:"/solana/functions/examples/basic-oracle-example"},next:{title:"Priority Fees",permalink:"/solana/feeds/priority-fees"}},l={},d=[{value:"Define Switchboard interface in your program",id:"define-switchboard-interface-in-your-program",level:2},{value:"Write a custom function in Rust",id:"write-a-custom-function-in-rust",level:2},{value:"Deploy function to Docker container",id:"deploy-function-to-docker-container",level:2},{value:"Create Switchboard function account",id:"create-switchboard-function-account",level:2},{value:"Create user and request account",id:"create-user-and-request-account",level:2},{value:"Request randomness",id:"request-randomness",level:2}],m={toc:d},p="wrapper";function h(e){let{components:t,...u}=e;return(0,r.kt)(p,(0,a.Z)({},m,u,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"randomness-callback"},"Randomness Callback"),(0,r.kt)("p",null,"Switchboard Functions can have ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'"sub-accounts"'))," called Function Request Account's which allow you to pass\na structured set of parameters to your function. This allows you to create request accounts for users where they\ncan be re-used or closed directly after use. Each request account has their own separate token balance, releiving the\nintegrater for managing user funds on their behalf. Because wrapped SOL is used for the oracle rewards, the Switchboard\nprogram will wrap any funds from the ",(0,r.kt)("inlineCode",{parentName:"p"},"payer")," account provided with the Cross Program Invocation (CPI)."),(0,r.kt)("p",null,"In this example we will build a program which allows a user to request randomness then await the result\noff-chain and determine if the user is correct."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Integration Checklist:")),(0,r.kt)("ul",{className:"contains-task-list"},(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Define Switchboard interface in your program"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Write a custom function in Rust"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Deploy function to Docker container"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Create Switchboard function account"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Create user and request account"),(0,r.kt)("li",{parentName:"ul",className:"task-list-item"},(0,r.kt)("input",{parentName:"li",type:"checkbox",checked:!1,disabled:!0})," ","Request randomness")),(0,r.kt)("h2",{id:"define-switchboard-interface-in-your-program"},"Define Switchboard interface in your program"),(0,r.kt)("p",null,"For our program we will have a basic User PDA setup that will keep track of our programs User that will interact with our program.\nIn our example we first make a ",(0,r.kt)("inlineCode",{parentName:"p"},"house_init")," instruction to initialize the top level program state and store the expected Function for our program.\nFor each randomness request we will make a ",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionRequestAccount")," pointing to this function, indicating which instruction to execute."),(0,r.kt)("p",null,"To integrate Switchboard Function requests you will need the following instructions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"request_init")," (user_guess in our example): An instruction to initialize the ",(0,r.kt)("inlineCode",{parentName:"li"},"FunctionRequestAccount")," with the expected container parameters.\nThis will mostly contain the Switchboard CPI to initialize the request and trigger it."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"request_settle")," (user_settle in our example): Some instruction to execute after the request has been verified by the Switchboard network\nto have been executed within a secure enclave. This will contain the core business logic and handle the result of your function.")),(0,r.kt)("p",null,"For each request we will pass the following parameters in the format ",(0,r.kt)("inlineCode",{parentName:"p"},"PID=XYZ,MAX_GUESS=10,USER=ABC"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct ContainerParams {\n    /// The program ID that is requesting randomness. Can be used for a generic function.\n    pub program_id: Pubkey,\n    /// The maximum guess the user submitted to bound the result from 1 to max_guess.\n    pub max_guess: u8,\n    /// The UserState account that submitted the guess.\n    pub user_key: Pubkey,\n}\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("strong",null,"user_guess:"),"The user will submit a guess and we will create the Switchboard ",(0,r.kt)("i",null,"FunctionRequestAccount")," that will be used to instruct the verifier which container to run and with what set of parameters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Context\n#[derive(Accounts)]\npub struct UserGuess<'info> {\n    // PROGRAM ACCOUNTS\n    #[account(\n      seeds = [PROGRAM_SEED],\n      bump = house.load()?.bump,\n      has_one = function,\n      constraint = house.load()?.token_wallet == house_token_wallet.key(),\n    )]\n    pub house: AccountLoader<'info, HouseState>,\n\n    #[account(\n        mut,\n        seeds = [PROGRAM_SEED, payer.key().as_ref()], // user should be paying for this each time\n        bump = user.load()?.bump,\n        constraint = user.load()?.authority == payer.key() && user.load()?.token_wallet == user_token_wallet.key(),\n    )]\n    pub user: AccountLoader<'info, UserState>,\n\n    // SWITCHBOARD ACCOUNTS\n    /// CHECK:\n    #[account(executable, address = SWITCHBOARD_ATTESTATION_PROGRAM_ID)]\n    pub switchboard: AccountInfo<'info>,\n    #[account(\n      seeds = [STATE_SEED],\n      seeds::program = switchboard.key(),\n      bump = state.load()?.bump,\n    )]\n    pub state: AccountLoader<'info, AttestationProgramState>,\n    pub attestation_queue: AccountLoader<'info, AttestationQueueAccountData>,\n    #[account(\n      mut,\n      has_one = attestation_queue,\n    )]\n    pub function: AccountLoader<'info, FunctionAccountData>,\n    /// CHECK:\n    #[account(\n      mut,\n      signer,\n      owner = system_program.key(),\n      constraint = request.data_len() == 0 && request.lamports() == 0\n    )]\n    pub request: AccountInfo<'info>,\n    /// CHECK:\n    #[account(\n      mut,\n      owner = system_program.key(),\n      constraint = request.data_len() == 0 && request.lamports() == 0\n    )]\n    pub request_escrow: AccountInfo<'info>,\n\n    // TOKEN ACCOUNTS\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n    #[account(address = anchor_spl::token::spl_token::native_mint::ID)]\n    pub mint: Account<'info, Mint>,\n    pub house_token_wallet: Box<Account<'info, TokenAccount>>,\n    #[account(mut)] // we might wrap funds to this wallet\n    pub user_token_wallet: Box<Account<'info, TokenAccount>>,\n\n    // SYSTEM ACCOUNTS\n    pub system_program: Program<'info, System>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n}\n\n// Instruction\npub fn user_guess(ctx: Context<UserGuess>, guess: u8, wager: u64) -> Result<()> {\n    if ctx.accounts.house_token_wallet.amount < GUESS_COST {\n        return Err(error!(RandomnessRequestError::HouseInsufficientFunds));\n    }\n\n    if ctx.accounts.user_token_wallet.amount < GUESS_COST {\n        wrap_native(\n            &ctx.accounts.system_program,\n            &ctx.accounts.token_program,\n            &ctx.accounts.user_token_wallet,\n            &ctx.accounts.payer,\n            &[&[\n                PROGRAM_SEED,\n                ctx.accounts.user.load()?.authority.key().as_ref(),\n                &[ctx.accounts.user.load()?.bump],\n            ]],\n            GUESS_COST\n                .checked_sub(ctx.accounts.user_token_wallet.amount)\n                .unwrap(),\n        )?;\n    }\n\n    ctx.accounts.user_token_wallet.reload()?;\n\n    assert!(\n        ctx.accounts.user_token_wallet.amount >= GUESS_COST,\n        \"User escrow is missing funds\"\n    );\n\n    let request_params = format!(\n        \"PID={},MAX_GUESS={},USER={}\",\n        crate::id(),\n        ctx.accounts.house.load()?.max_guess,\n        ctx.accounts.user.key()\n    );\n\n    let request_init_ctx = FunctionRequestInitAndTrigger {\n        request: ctx.accounts.request.clone(),\n        function: ctx.accounts.function.clone(),\n        escrow: ctx.accounts.request_escrow.clone(),\n        mint: ctx.accounts.mint.clone(),\n        state: ctx.accounts.state.clone(),\n        attestation_queue: ctx.accounts.attestation_queue.clone(),\n        payer: ctx.accounts.payer.clone(),\n        system_program: ctx.accounts.system_program.clone(),\n        token_program: ctx.accounts.token_program.clone(),\n        associated_token_program: ctx.accounts.associated_token_program.clone(),\n    };\n    request_init_ctx.invoke(\n        ctx.accounts.switchboard.clone(),\n        None,\n        Some(1000),\n        Some(512),\n        Some(request_params.into_bytes()),\n        None,\n    )?;\n\n    let mut user = ctx.accounts.user.load_mut()?;\n    user.last_round = user.current_round;\n    user.current_round = UserRound {\n        guess,\n        wager,\n        request: ctx.accounts.request.key(),\n        status: RoundStatus::Pending,\n        result: 0,\n        slot: Clock::get()?.slot,\n        timestamp: Clock::get()?.unix_timestamp,\n    };\n\n    Ok(())\n}\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("strong",null,"user_settle:"),"Within our Docker container we will generate a random number based on the ",(0,r.kt)("i",null,"max_guess")," then build the user_settle instruction to determine if the user won."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Context\n#[derive(Accounts)]\npub struct UserSettle<'info> {\n    // CLIENT ACCOUNTS\n    #[account(\n      seeds = [PROGRAM_SEED],\n      bump = house.load()?.bump,\n      has_one = function,\n    )]\n    pub house: AccountLoader<'info, HouseState>,\n\n    #[account(\n        mut,\n        seeds = [PROGRAM_SEED, user.load()?.authority.as_ref()],\n        bump = user.load()?.bump,\n        constraint = user.load()?.token_wallet == user_token_wallet.key(),\n    )]\n    pub user: AccountLoader<'info, UserState>,\n\n    // SWITCHBOARD ACCOUNTS\n    pub function: AccountLoader<'info, FunctionAccountData>,\n    #[account(\n      constraint = request.validate_signer(\n          &function.to_account_info(),\n          &enclave_signer.to_account_info()\n        )? @ RandomnessRequestError::FunctionValidationFailed,\n    )]\n    pub request: Box<Account<'info, FunctionRequestAccountData>>,\n    pub enclave_signer: Signer<'info>,\n\n    // TOKEN ACCOUNTS\n    pub token_program: Program<'info, Token>,\n    #[account(address = anchor_spl::token::spl_token::native_mint::ID)]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub house_token_wallet: Box<Account<'info, TokenAccount>>,\n    #[account(mut)]\n    pub user_token_wallet: Box<Account<'info, TokenAccount>>,\n}\n\n// Instruction\npub fn user_settle(ctx: Context<UserSettle>, result: u8) -> Result<()> {\n    // verify we havent responded already\n    if ctx.accounts.user.load()?.current_round.status != RoundStatus::Pending {\n        return Err(error!(RandomnessRequestError::RoundInactive));\n    }\n\n    if ctx.accounts.request.active_request.status != RequestStatus::RequestSuccess {\n        return Err(error!(\n            RandomnessRequestError::SwitchboardRequestNotSuccessful\n        ));\n    }\n\n    let mut user = ctx.accounts.user.load_mut()?;\n    user.current_round.result = result;\n    user.current_round.status = RoundStatus::Settled;\n\n    // TODO: payout\n\n    Ok(())\n}\n"))),(0,r.kt)("h2",{id:"write-a-custom-function-in-rust"},"Write a custom function in Rust"),(0,r.kt)("p",null,"Our function is verify simple because we are able to generate randomness within the enclave. ",(0,r.kt)("strong",{parentName:"p"},"All you need to generate randomness is one line ",(0,r.kt)("inlineCode",{parentName:"strong"}," Gramine::read_rand(&mut bytes)"),"!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::str::FromStr;\n\npub use switchboard_solana::get_ixn_discriminator;\npub use switchboard_solana::prelude::*;\n\nmod params;\npub use params::*;\n\n#[tokio::main(worker_threads = 12)]\nasync fn main() {\n    // First, initialize the runner instance with a freshly generated Gramine keypair\n    let runner = FunctionRunner::new_from_cluster(Cluster::Devnet, None).unwrap();\n\n    // parse and validate user provided request params\n    let params = ContainerParams::decode(&runner.fn_request_data.container_params).unwrap();\n\n    // Determine the final result\n    let mut bytes: [u8; 1] = [0u8; 1];\n    Gramine::read_rand(&mut bytes).expect("gramine failed to generate randomness");\n    let result = (bytes[0] % params.max_guess) + 1;\n\n    // derive pubkeys to build ixn\n    let (house_pubkey, _house_bump) =\n        Pubkey::find_program_address(&[b"CUSTOMRANDOMNESS"], &params.program_id);\n    let mint = anchor_spl::token::spl_token::native_mint::ID;\n    let house_escrow =\n        anchor_spl::associated_token::get_associated_token_address(&house_pubkey, &mint);\n    let user_escrow =\n        anchor_spl::associated_token::get_associated_token_address(&params.user_key, &mint);\n\n    // build ixn data from discriminator and result\n    let mut ixn_data = get_ixn_discriminator("user_settle").to_vec();\n    ixn_data.push(result);\n\n    let user_settle_ixn = Instruction {\n        program_id: params.program_id,\n        data: ixn_data,\n        accounts: vec![\n            AccountMeta::new_readonly(house_pubkey, false),\n            AccountMeta::new(params.user_key, false),\n            AccountMeta::new_readonly(runner.function, false),\n            AccountMeta::new_readonly(runner.fn_request_key, false),\n            AccountMeta::new_readonly(runner.signer, true),\n            AccountMeta::new_readonly(anchor_spl::token::ID, false),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new(house_escrow, false),\n            AccountMeta::new(user_escrow, false),\n        ],\n    };\n\n    // Then, write your own Rust logic and build a Vec of instructions.\n    // Should  be under 700 bytes after serialization\n    let ixs: Vec<solana_program::instruction::Instruction> = vec![user_settle_ixn];\n\n    // Finally, emit the signed quote and partially signed transaction to the functionRunner oracle\n    // The functionRunner oracle will use the last outputted word to stdout as the serialized result. This is what gets executed on-chain.\n    runner.emit(ixs).await.unwrap();\n}\n')),(0,r.kt)("h2",{id:"deploy-function-to-docker-container"},"Deploy function to Docker container"),(0,r.kt)("p",null,"The template repository includes a Makefile to streamline publishing your\ncontainer to the docker repository along with outputting your MrEnclave\nmeasurement. This measurement corresponds to the code fingerprint of the\noutputted Rust binary. You should store this value in the function account we\ncreate in the following step. This will ensure that the only code that is\nallowed to add data to your smart contract must be generated from a binary with\nthis signature. You can add multiple MrEnclave values to your function account\nto allow backwards compatibility and make upgrades easier."),(0,r.kt)("p",null,"Edit the Makefile and add your docker registry."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-makefile"},"# Variables\n## Cargo.toml name of the compiled binary\nCARGO_NAME=switchboard-function\n## Docker registry image name (Ex: switchboardlabs/basic-oracle-function)\nDOCKER_IMAGE_NAME=switchboard-function\n")),(0,r.kt)("p",null,"Use one of the following commands to compile your function:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Command"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"make")),(0,r.kt)("td",{parentName:"tr",align:null},"Build the container locally and output the MrEnclave measurement")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"make publish")),(0,r.kt)("td",{parentName:"tr",align:null},"Publish the container to the provided docker repository under the latest tag")))),(0,r.kt)("h2",{id:"create-switchboard-function-account"},"Create Switchboard function account"),(0,r.kt)("p",null,"Next we need to create our function account on-chain. We will define an empty\ncron schedule to effectively disable the scheuled executions of our containers; for our example\nwe only need to execute custom requests when our users make a request. We do not need to fund our function\nbecause our users will wrap SOL to pay for the request."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{attributes:{className:"navbar_icon__switchboard"},value:"ui",label:"Web App",default:!0,mdxType:"TabItem"},(0,r.kt)("p",null,"Visit the Switchboard app:\n",(0,r.kt)("a",{parentName:"p",href:"https://beta.app.switchboard.xyz/"},"beta.app.switchboard.xyz")),(0,r.kt)("p",null,"In the top right, sign in to your Solana wallet for the selected cluster."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Switchboard App Sign-in Solana",src:n(87082).Z,width:"1058",height:"356"})),(0,r.kt)("p",null,"Then click build and start configuring your function"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Switchboard App Function Config Modal",src:n(8719).Z,width:"691",height:"654"}))),(0,r.kt)(s.Z,{attributes:{className:"navbar_icon__javascript"},value:"javascript",label:"@switchboard-xyz/solana.js",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import {\n  AttestationQueueAccount,\n  FunctionAccount,\n  parseMrEnclave,\n  SwitchboardProgram,\n} from "@switchboard-xyz/solana.js";\n\n// Load the Switchboard program and an existing Attestation Queue\nconst program = await SwitchboardProgram.load(\n  "devnet",\n  new Connection("https://api.devnet.solana.com"),\n  payerKeypair\n);\nconst [attestationQueueAccount, queueAccountData] =\n  await AttestationQueueAccount.load(program, "My Attestation Queue Pubkey");\n\n// Create the FunctionAccount\nconst [functionAccount, txnSignature] = await FunctionAccount.create(\n  ctx.program,\n  {\n    name: "FUNCTION_NAME",\n    metadata: "FUNCTION_METADATA",\n    schedule: "",\n    container: "switchboardlabs/randomness-function",\n    mrEnclave: parseMrEnclave("my MrEnclave value"),\n    attestationQueue: attestationQueueAccount,\n  }\n);\n\n// Wrap 0.25 SOL into the functionAccount wallet\nawait functionAccount.wrap(0.25);\n'))),(0,r.kt)(s.Z,{attributes:{className:"navbar_icon__terminal"},value:"CLI",label:"sbv2 CLI",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'sbv2 solana function create CkvizjVnm2zA5Wuwan34NhVT3zFc7vqUyGnA6tuEF5aE \\\n  --name "My Function" \\\n  --metadata "Randomness Callback" \\\n  --schedule "" \\\n  --containerRegistry dockerhub \\\n  --container switchboardlabs/randomness-function \\\n  --keypair ~/.config/solana/id.json\n')))),(0,r.kt)("h2",{id:"create-user-and-request-account"},"Create user and request account"),(0,r.kt)("h2",{id:"request-randomness"},"Request randomness"))}h.isMDXComponent=!0},8719:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/explorer-function-config-6774944f1093f5d5eb17c9a21a575e04.png"},87082:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/explorer-sign-in-bfc99ca60a9c0aec073d6022d098c74a.png"}}]);