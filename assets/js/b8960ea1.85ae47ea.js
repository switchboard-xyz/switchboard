"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[72430],{54852:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(49231);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||l;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},90288:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var r=n(48041),a=(n(49231),n(54852));const l={sidebar_position:12,title:"Advanced Walkthrough"},o=void 0,i={unversionedId:"solana/advanced-walkthrough",id:"solana/advanced-walkthrough",title:"Advanced Walkthrough",description:"This guide will walk you through building a ticket raffle on Solana, utilizing",source:"@site/docs/solana/advanced-walkthrough.mdx",sourceDirName:"solana",slug:"/solana/advanced-walkthrough",permalink:"/solana/advanced-walkthrough",draft:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12,title:"Advanced Walkthrough"}},s={},u=[{value:"The Raffle Program",id:"the-raffle-program",level:2},{value:"Accounts",id:"accounts",level:3},{value:"Instructions",id:"instructions",level:3},{value:"Constraints",id:"constraints",level:3},{value:"Buidl",id:"buidl",level:2},{value:"<code>program_init</code>",id:"program_init",level:3}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This guide will walk you through building a ticket raffle on Solana, utilizing\nSwitchboard oracles and VRF for provable fairness."),(0,a.kt)("h2",{id:"the-raffle-program"},"The Raffle Program"),(0,a.kt)("p",null,"We'll be building a basic ticket raffle that lets a user deposit 1 USDC worth of\ntheir favorite SPL Token and in return receive a raffle ticket. We'll utilize\nSwitchboard oracles in order to determine the amount of SPL Tokens to deposit so\nthe user is always exchanging 1 USDC worth. After some pre-determined amount of\ntime, the raffle will close and the program will request randomness from\nSwitchboard. Once the randomness is fulfilled, the Switchboard oracle will make\na cross-program invocation into our program and select the winner. This is web3\nso we'll make it so any user can create their own lottery and invite users to\nparticipate."),(0,a.kt)("h3",{id:"accounts"},"Accounts"),(0,a.kt)("p",null,"Our program will need the following accounts:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Account"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"ProgramState"),(0,a.kt)("td",{parentName:"tr",align:null},"Top level program PDA that will enforce all lotteries can only be created for a given Switchboard OracleQueue. ",(0,a.kt)("br",null),(0,a.kt)("br",null),"This ensures a lottery authority cant create their own queue and oracles and cheat the users.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Lottery"),(0,a.kt)("td",{parentName:"tr",align:null},"Contains the:",(0,a.kt)("br",null),(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("b",null,"LotteryConfig:")," the duration, closing timestamp, and number of participants"),(0,a.kt)("li",null,(0,a.kt)("b",null,"TokenConfig:")," the token mint, escrow, and the Switchboard Aggregator to use for pricing data"),(0,a.kt)("li",null,(0,a.kt)("b",null,"VrfConfig:")," the Switchboard VRF to settle the results")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Ticket"),(0,a.kt)("td",{parentName:"tr",align:null},"Stores the user's raffle ticket and reward addresses.")))),(0,a.kt)("h3",{id:"instructions"},"Instructions"),(0,a.kt)("p",null,"Our program will need the following instructions:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Instruction"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"program_init")),(0,a.kt)("td",{parentName:"tr",align:null},"Initialize the ProgramState account and set the Switchboard OracleQueue.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"lottery_init")),(0,a.kt)("td",{parentName:"tr",align:null},"Initialize a lottery with a set of parameters.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"ticket_init")),(0,a.kt)("td",{parentName:"tr",align:null},"Transfer 1 USDC worth of a user's tokens to the lottery controlled escrow address and initialize a ticket for the user.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"lottery_draw")),(0,a.kt)("td",{parentName:"tr",align:null},"Request randomness from the Switchboard OracleQueue.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"lottery_settle")),(0,a.kt)("td",{parentName:"tr",align:null},"This will be invoked by the Switchboard oracle and handle any logic for determining the winner. ",(0,a.kt)("br",null),(0,a.kt)("br",null),(0,a.kt)("b",null,"NOTE:")," This will be our callback instruction.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"lottery_close")),(0,a.kt)("td",{parentName:"tr",align:null},"After the lottery has been settled, allow a lottery authority to close a lottery and recoup any rent exemption.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"ticket_close")),(0,a.kt)("td",{parentName:"tr",align:null},"After the lottery has been settled, allow a user to close their ticket account and recoup any rent exemption.")))),(0,a.kt)("h3",{id:"constraints"},"Constraints"),(0,a.kt)("p",null,"Let's quickly sketch out some edge cases we may encounter."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"No Users Enter the Lottery")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We should enforce some minimum number of participants for our lottery. We dont\nwant to request randomness if no one will win.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"User Buys a Ticket After the Lottery Ends")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We should enforce an ending timestamp on the lottery so a user cannot purchase\na ticket after a certain timestamp.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Lottery Oracle Stale")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We should define an oracles config so it is updating at a regular cadence."),(0,a.kt)("li",{parentName:"ul"},"If the oracle is more than 5 minutes stale, we should prevent users from\npurchasing any tickets."),(0,a.kt)("li",{parentName:"ul"},"If the oracle's confidence interval (standard deviation) exceeds some\nthreshold, we should prevent the user from purchasing any tickets."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"TWAP"),": For more advanced cases we can utilize a Twap oracle so individual\nprice samples are averaged out.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"VRF Request Failed")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We should have some logic to re-request randomness if a previous request has\nfailed."),(0,a.kt)("li",{parentName:"ul"},"We should prevent multiple concurrent requests by enforcing some minimum time\nbetween requests."),(0,a.kt)("li",{parentName:"ul"},"We should have some maximum number of retries that closes the lottery and\nlet's users recoup their entrance fee.")),(0,a.kt)("h2",{id:"buidl"},"Buidl"),(0,a.kt)("p",null,"Let's setup our anchor project and add some dependencies."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"anchor init vrf-raffle\ncd vrf-raffle\n# javascript dependencies\nyarn remove @project-serum/anchor\nyarn add @coral-xyz/anchor \\\n  @solana/web3.js \\\n  @solana/spl-token \\\n  @switchboard-xyz/solana.js \\\n  @switchboard-xyz/common\n# rust dependencies\ncargo add switchboard-v2\ncargo add bytemuck\ncargo add solana-program\ncargo add anchor-spl\n")),(0,a.kt)("p",null,"Create your program deploy keypair, then update ",(0,a.kt)("inlineCode",{parentName:"p"},"Anchor.toml")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"programs/vrf-raffle/src/lib.rs")," with your unique program ID and build the\nprogram."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# create\nsolana-keygen new -s --no-bip39-passphrase --outfile target/deploy/vrf_raffle-keypair.json\nexport VRF_RAFFLE_PROGRAM_ID=$(solana-keygen pubkey target/deploy/vrf_raffle-keypair.json)\nsed -i '' 's/Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS/'\"$VRF_RAFFLE_PROGRAM_ID\"'/' Anchor.toml\nsed -i '' 's/Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS/'\"$VRF_RAFFLE_PROGRAM_ID\"'/' programs/vrf-raffle/src/lib.rs\nanchor build\n")),(0,a.kt)("p",null,"Commit your changes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'git add --all && git commit -m "init"\n')),(0,a.kt)("h3",{id:"program_init"},(0,a.kt)("inlineCode",{parentName:"h3"},"program_init")),(0,a.kt)("p",null,"First, let's remove the generated initialize instruction and replace it with the\nboilerplate code for our ",(0,a.kt)("inlineCode",{parentName:"p"},"program_init")," instruction. Then we'll add the\nProgramState account layout. We'll be storing the Switchboard programState bump\non our account so we dont need to provide it everytime we request randomness."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="programs/vrf-raffle/src/program_init.rs"',title:'"programs/vrf-raffle/src/program_init.rs"'},"use anchor_lang::prelude::*;\n\n#[derive(Accounts)]\npub struct ProgramInit {}\n\n#[derive(Clone, AnchorSerialize, AnchorDeserialize)]\npub struct ProgramInitParams {}\n\nimpl ProgramInit {\n    pub fn validate(\n        &self,\n        ctx: &Context<Self>,\n        params: &ProgramInitParams,\n    ) -> anchor_lang::Result<()> {\n        Ok(())\n    }\n\n    pub fn actuate(ctx: &Context<Self>, params: &ProgramInitParams) -> anchor_lang::Result<()> {\n        Ok(())\n    }\n}\n\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff",metastring:'title="programs/vrf-raffle/src/lib.rs"',title:'"programs/vrf-raffle/src/lib.rs"'},'use anchor_lang::prelude::*;\n\n+ pub mod program_init;\n+ pub use program_init::*;\n\ndeclare_id!("4frepJahiLDWX4apn4XErpXcHUWSJEsjDVmrmrhAGBQn");\n\n#[program]\npub mod vrf_raffle {\n    use super::*;\n\n-     pub fn program_init(ctx: Context<Initialize>) -> Result<()> {\n-         Ok(())\n-     }\n+     #[access_control(ctx.accounts.validate(&ctx, &params))]\n+     pub fn program_init(\n+         ctx: Context<ProgramInit>,\n+         params: ProgramInitParams,\n+     ) -> anchor_lang::Result<()> {\n+         ProgramInit::actuate(&ctx, &params)\n+     }\n}\n\n- #[derive(Accounts)]\n- pub struct Initialize {}\n\n+ #[account(zero_copy)]\n+ #[derive(AnchorSerialize)]\n+ pub struct ProgramState {\n+     pub bump: u8,\n+     pub switchboard_state_bump: u8,\n+     pub switchboard_queue: Pubkey,\n+     // Buffer for future use\n+     pub _ebuf: [u8; 1024],\n+ }\n')),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Add explanation for zero_copy and why its needed")),(0,a.kt)("p",null,"Great, we created the empty ",(0,a.kt)("inlineCode",{parentName:"p"},"program_init")," instruction. We'll be following this\npattern for all of our instructions where each gets its own module which then\ngets mapped in lib.rs with an access control to validate the parameters."),(0,a.kt)("p",null,"Now let's add some functionality to our ",(0,a.kt)("inlineCode",{parentName:"p"},"program_init")," instruction. We will need\nto:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Allocate on-chain space for our ProgramState account"),(0,a.kt)("li",{parentName:"ul"},"Deserialize the Switchboard ProgramStateAccount and store the bump on our\naccount"),(0,a.kt)("li",{parentName:"ul"},"Deserialize a provided Switchboard OracleQueueAccountData and ensure it has\nunpermissionedVrf set to true")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="programs/vrf-raffle/src/program_init.rs"',title:'"programs/vrf-raffle/src/program_init.rs"'},"")))}d.isMDXComponent=!0}}]);