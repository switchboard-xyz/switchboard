syntax = "proto2";

package oracle_job;

/// Represnts a list of tasks to be performed by a switchboard oracle.
message OracleJob {
/*
The adapter will report the text body of a successful HTTP request to the
specified url, or return an error if the response status code is greater
than or equal to 400.

_**Input**_: None

_**Returns**_: String representation of the http response.

_**Example**_: Basic HttpTask

```json
{"httpTask": {"url": "https://mywebsite.org/path"} }
```

_**Example**_: HttpTask example with headers

```json
{ "httpTask": { "url": "https://mywebsite.org/path", "method": "METHOD_POST", "headers": [ { "key": "MY_HEADER_KEY", "value": "MY_HEADER_VALUE" } ], "body": "{\"MY_BODY_KEY\":\"MY_BODY_VALUE\"}" } }
```
*/
  message HttpTask {
    /// An enumeration representing the types of HTTP requests available to make.
    enum Method {
      /// Unset HTTP method will default to METHOD_GET
      METHOD_UNKOWN = 0;
      /// Perform an HTTP 'GET' request.
      METHOD_GET = 1;
      /// Perform an HTTP 'POST' request.
      METHOD_POST = 2;
    }

    /// An object that represents a header to add to an HTTP request.
    message Header {
      /// A header key such as `Authorization` or `Content-Type`
      optional string key = 1;
      /// A value for the given header key like `Basic MYAUTHKEY` or `application/json`
      optional string value = 2;
    }
    /// A string containing the URL to direct this HTTP request to.
    optional string url = 1;

    /// The type of HTTP request to make.
    optional Method method = 2;

    /// A list of headers to add to this HttpTask.
    repeated Header headers = 3;

    /// A stringified body (if any) to add to this HttpTask.
    optional string body = 4;
  }

/*
The adapter walks the path specified and returns the value found at that result. If returning
JSON data from the HttpGet or HttpPost adapters, you must use this adapter to parse the response.

_**Input**_: String representation of a JSON object.

_**Returns**_: A numerical result.

_**Example**_: Parses the price field from a JSON object

```json
{"jsonParse": {"path": "$.price"} }
```
*/
  message JsonParseTask {
    /// JSONPath formatted path to the element. https://t.ly/uLtw
    /// https://www.npmjs.com/package/jsonpath-plus
    optional string path = 1;

    /// The methods of combining a list of numerical results.
    enum AggregationMethod {
      NONE = 0;
      /// Grab the minimum value of the results.
      MIN = 1;
      /// Grab the maximum value of the results.
      MAX = 2;
      /// Sum up all of the results.
      SUM = 3;
      /// Average all of the results.
      MEAN = 4;
      /// Grab the median of the results.
      MEDIAN = 5;
    }
    /// The technique that will be used to aggregate the results if walking the specified path returns multiple numerical results.
    optional AggregationMethod aggregation_method = 2;
  }

/*
Returns the median (middle) of all the results returned by the provided subtasks and subjobs. Nested tasks must return a Number.

_**Input**_: None

_**Returns**_: A numerical result.

_**Example**_: Returns the median numerical result of 3 tasks.

```json
{"medianTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
```

_**Example**_: Returns the median numerical result of 3 jobs.

```json
{"medianTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
```
*/
  message MedianTask {
    /// A list of subtasks to process and produce a list of result values.
    repeated Task tasks = 1;
    /// A list of subjobs to process and produce a list of result values.
    repeated OracleJob jobs = 2;
    /// The minimum number of values before a successful median can be yielded.
    optional int32 min_successful_required = 3;
    /// The maximum range between the minimum and maximum values before a successful median can be yielded.
    optional string max_range_percent = 4;
  }

/*
Returns the mean (average) of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.

_**Input**_: None

_**Returns**_: A numerical result.

_**Example**_: Returns the mean numerical result of 3 tasks.

```json
{"meanTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
```

_**Example**_: Returns the mean numerical result of 3 jobs.

```json
{"meanTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
```
*/
  message MeanTask {
    /// A list of subtasks to process and produce a list of result values.
    repeated Task tasks = 1;
    /// A list of subjobs to process and produce a list of result values.
    repeated OracleJob jobs = 2;
  }

/*
Returns the maximum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.

_**Input**_: None

_**Returns**_: A numerical result.

_**Example**_: Returns the maximum numerical result from 3 tasks.

```json
{"maxTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
```

_**Example**_: Returns the maximum numerical result from 3 jobs.

```json
{"maxTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
```
*/
  message MaxTask {
    /// A list of subtasks to process and produce a list of result values.
    repeated Task tasks = 1;
    /// A list of subjobs to process and produce a list of result values.
    repeated OracleJob jobs = 2;
  }

/*
Returns the minimum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.

_**Input**_: None

_**Returns**_: A numerical result.

_**Example**_: Returns the minimum numerical result from 3 tasks.

```json
{"minTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
```

_**Example**_: Returns the minimum numerical result from 3 jobs.

```json
{"minTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
```
*/
  message MinTask {
    /// A list of subtasks to process and produce a list of result values.
    repeated Task tasks = 1;
    /// A list of subjobs to process and produce a list of result values.
    repeated OracleJob jobs = 2;
  }

/*
Returns a specified value.

_**Input**_: None

_**Returns**_: A numerical result.

_**Example**_: Returns the value 10

```json
{"valueTask": {"value": 10} }
```

_**Example**_: Returns the currentRound result of an aggregator

```json
{"valueTask": {"aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"} }
```

_**Example**_: Returns the value stored in a CacheTask variable

```json
{"valueTask": {"big": "${ONE}"} }
```
*/
  message ValueTask {
    oneof Value {
      /// The value that will be returned from this task.
      double value = 1;
      /// Specifies an aggregatorr to pull the value of.
      string aggregator_pubkey = 2;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 3;
      /// A stringified hex number (0x prefix is optional).
      string hex = 4;
    }
  }

/*
Opens and maintains a websocket for light speed data retrieval.

_**Input**_: None

_**Returns**_: String representation of the websocket subscription message.

_**Example**_: Opens a coinbase websocket

```json
{ "websocketTask": { "url": "wss://ws-feed.pro.coinbase.com", "subscription": "{\"type\":\"subscribe\",\"product_ids\":[\"BTC-USD\"],\"channels\":[\"ticker\",{\"name\":\"ticker\",\"product_ids\":[\"BTC-USD\"]}]}", "maxDataAgeSeconds": 15, "filter": "$[?(@.type == 'ticker' && @.product_id == 'BTC-USD')]" } }
```
*/
  message WebsocketTask {
    /// The websocket url.
    optional string url = 1;
    /// The websocket message to notify of a new subscription.
    optional string subscription = 2;
    /// Minimum amount of time required between when the horses are taking out.
    optional int32 max_data_age_seconds = 3;
    /// Incoming message JSONPath filter.
    /// Example: "$[?(@.channel == 'ticker' && @.market == 'BTC/USD')]"
    optional string filter = 4;
  }

/*
This task will run the `attempt` on the subtasks in an effort to produce a valid numerical result. If `attempt`. fails to produce an acceptable result, `on_failure` subtasks will be run instead.

_**Input**_: The current running numerical result output from a task.

_**Returns**_: A numerical result, else run `on_failure` subtasks.

_**Example**_: Returns the numerical result from the conditionalTask's subtasks, else `on_failure` returns the numerical result from its subtasks.

```json
{"conditionalTask":{"attempt":[{"tasks":[{"jupiterSwapTask":{"inTokenAddress":"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v","outTokenAddress":"DUALa4FC2yREwZ59PHeu1un4wis36vHRv5hWVBmzykCJ"}}]}],"onFailure":[{"lpExchangeRateTask":{"orcaPoolAddress":"7yJ4gMRJhEoCR48aPE3EAWRmCoygakik81ZS1sajaTnE"}}]}}
```
*/
  message ConditionalTask {
    /// A list of subtasks to process in an attempt to produce a valid numerical result.
    repeated Task attempt = 1;
    /// A list of subtasks that will be run if `attempt` subtasks are unable to produce an acceptable
    /// result.
    repeated Task on_failure = 2;
  }

/*
This task will divide a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.

_**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.

_**Returns**_: A numerical result.

_**Example**_: Returns the numerical result by dividing by a job of subtasks.

```json
{"tasks":[{"valueTask":{"value":100}},{"divideTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
```

_**Example**_: Returns the numerical result by dividing by an aggregator.

```json
{"tasks":[{"valueTask":{"value":100}},{"divideTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
```

_**Example**_: Returns the numerical result by dividing by a big.

```json
{"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"divideTask":{"big":"${TEN}"}}]}
```
*/
  message DivideTask {
    oneof Denominator {
      /// Specifies a basic scalar denominator to divide by.
      double scalar = 1;
      /// Specifies another aggregator resut to divide by.
      string aggregator_pubkey = 2;
      /// A job whose result is computed before dividing our numerical input by that result.
      OracleJob job = 3;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 4;
    }
  }

/*
This task will multiply a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.

_**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.

_**Returns**_: A numerical result.

_**Example**_: Returns the numerical result by multiplying by a job of subtasks.

```json
{"tasks":[{"valueTask":{"value":100}},{"multiplyTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
```

_**Example**_: Returns the numerical result by multiplying by an aggregator.

```json
{"tasks":[{"valueTask":{"value":100}},{"multiplyTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
```

_**Example**_: Returns the numerical result by multiplying by a big.

```json
{"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"multiplyTask":{"big":"${TEN}"}}]}
```
*/
  message MultiplyTask {
    oneof Multiple {
      /// Specifies a scalar to multiply by.
      double scalar = 1;
      /// Specifies an aggregator to multiply by.
      string aggregator_pubkey = 2;
      /// A job whose result is computed before multiplying our numerical input by that result.
      OracleJob job = 3;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 4;
    }
  }

/*
This task will add a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.

_**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.

_**Returns**_: A numerical result.

_**Example**_: Returns the numerical result by adding by a job of subtasks.

```json
{"tasks":[{"valueTask":{"value":100}},{"addTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
```

_**Example**_: Returns the numerical result by multiplying by an aggregator.

```json
{"tasks":[{"valueTask":{"value":100}},{"addTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
```

_**Example**_: Returns the numerical result by multiplying by a big.

```json
{"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"addTask":{"big":"${TEN}"}}]}
```
*/
  message AddTask {
    oneof Addition {
      /// Specifies a scalar to add by.
      double scalar = 1;
      /// Specifies an aggregator to add by.
      string aggregator_pubkey = 2;
      /// A job whose result is computed before adding our numerical input by that result.
      OracleJob job = 3;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 4;
    }
  }

/*
This task will subtract a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.

_**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.

_**Returns**_: A numerical result.

_**Example**_: Returns the numerical result by subtracting by a job of subtasks.

```json
{"tasks":[{"valueTask":{"value":100}},{"subtractTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
```

_**Example**_: Returns the numerical result by multiplying by an aggregator.

```json
{"tasks":[{"valueTask":{"value":100}},{"subtractTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
```

_**Example**_: Returns the numerical result by multiplying by a big.

```json
{"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"subtractTask":{"big":"${TEN}"}}]}
```
*/
  message SubtractTask {
    oneof Subtraction {
      /// Specifies a scalar to subtract by.
      double scalar = 1;
      /// Specifies an aggregator to subtract by.
      string aggregator_pubkey = 2;
      /// A job whose result is computed before subtracting our numerical input by that result.
      OracleJob job = 3;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 4;
    }
  }


/*
Fetch LP token price info from a number of supported exchanges.

See our blog post on [Fair LP Token Oracles](/blog/2022/01/20/Fair-LP-Token-Oracles)

**NOTE**: This is not the swap price but the price of the underlying LP token.

_**Input**_: None

_**Returns**_: The price of an LP token for a given AMM pool.

_**Example**_: Fetch the Orca LP token price of the SOL/USDC pool

```json
{ "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
```

_**Example**_: Fetch the fair price Orca LP token price of the SOL/USDC pool

```json
{ "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9", "useFairPrice": true, "priceFeedAddresses": [ "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" ] } }
```

_**Example**_: Fetch the fair price Raydium LP token price of the SOL/USDC pool

```json
{ "lpTokenPriceTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", "useFairPrice": true,"priceFeedAddresses": ["GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR","BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" ] } }
```
*/
  message LpTokenPriceTask {
    oneof PoolAddress {
      /// Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
      string mercurial_pool_address = 1;
      /// Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
      string saber_pool_address = 2;
      /// Orca pool address. A full list can be found here: https://www.orca.so/pools
      string orca_pool_address = 3;
      /// The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
      string raydium_pool_address = 4;
    }
    /// A list of Switchboard aggregator accounts used to calculate the fair LP price. This ensures the price is based on the previous round to mitigate flash loan price manipulation.
    repeated string price_feed_addresses = 5;
    /// A list of OracleJobs to execute in order to yield the price feed jobs to use for the fair price formula.
    repeated OracleJob price_feed_jobs = 6;
    /// If enabled and price_feed_addresses provided, the oracle will calculate the fair LP price based on the liquidity pool reserves. See our blog post for more information: https://switchboardxyz.medium.com/fair-lp-token-oracles-94a457c50239
    optional bool use_fair_price = 7;
  }

/*
Fetch the current swap price for a given liquidity pool

_**Input**_: None

_**Returns**_: The swap price for a given AMM pool.

_**Example**_: Fetch the exchange rate from the Orca SOL/USDC pool

```json
{ "lpExchangeRateTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
```

_**Example**_: Fetch the exchange rate from the Raydium SOL/USDC pool

```json
{ "lpExchangeRateTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2" } }
```
*/
  message LpExchangeRateTask {
    /// Used alongside mercurial_pool_address to specify the input token for a swap.
    optional string in_token_address = 1;
    /// Used alongside mercurial_pool_address to specify the output token for a swap.
    optional string out_token_address = 2;
    oneof PoolAddress {
      /// Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
      string mercurial_pool_address = 3;
      /// Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
      string saber_pool_address = 4;
      /// **@deprecated** Use orcaPoolAddress
      string orca_pool_token_mint_address = 5 [deprecated=true];
      /// The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
      string raydium_pool_address = 6;
      /// Pool address for an Orca LP pool or whirlpool.
      /// A full list of Orca LP pools can be found here: https://www.orca.so/pools
      string orca_pool_address = 7;
      /// The Port reserve pubkey. A full list can be found here: https://api-v1.port.finance/reserves
      string port_reserve_address = 8;
    }
  }


  /// Find a pattern within a string of a previous task and extract a group number.
  message RegexExtractTask {
    /// Regex pattern to find.
    optional string pattern = 1;
    /// Group number to extract.
    optional int32 group_number = 2;
  }

  message XStepPriceTask {
    oneof StepSource {
      /// median task containing the job definitions to fetch the STEP/USD price
      MedianTask step_job = 1;
      /// existing aggregator pubkey for STEP/USD
      string step_aggregator_pubkey = 2;
    }
  }

/*
Takes a twap over a set period for a certain aggregator. Aggregators have an optional history buffer account storing the last N accepted results. The TwapTask will iterate over an aggregators history buffer and calculate the time weighted average of the samples within a given time period.

_**Input**_: None

_**Returns**_: The time weighted average of an aggregator over a given time period.

_**Example**_: The 1hr Twap of the SOL/USD Aggregator, requiring at least 60 samples.

```json
{ "twapTask": { "aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "period": 3600, "minSamples": 60, "weightByPropagationTime": true  } }
```
*/
  message TwapTask {
    /// The target aggregator for the TWAP.
    optional string aggregator_pubkey = 1;
    /// Period, in seconds, the twap should account for
    optional int32 period = 2;
    /// Weight samples by their propagation time
    optional bool weight_by_propagation_time = 3;
    /// Minimum number of samples in the history to calculate a valid result
    optional uint32 min_samples = 4;
    /// Ending unix timestamp to collect values up to
    optional int32 ending_unix_timestamp = 5;
    /// Execute the task to get the ending unix timestamp
    optional CronParseTask ending_unix_timestamp_task = 6;
  }

  /// Fetch the latest swap price on Serum's orderbook
  message SerumSwapTask {
    /// The serum pool to fetch swap price for
    optional string serum_pool_address = 1;
  }

/*
Round the current running result to an exponential power.

_**Input**_: The current running numerical result.

_**Returns**_: The input raised to an exponential power.

_**Example**_: Raise 2 to the power of 3, 2^3

```json
{"tasks":[{"valueTask":{"value":2}},{"powTask":{"scalar":3}}]}
```
*/
  message PowTask {
    oneof Exponent {
      /// Take the working value to the exponent of value.
      double scalar = 1;
      /// Take the working value to the exponent of the aggregators value.
      string aggregator_pubkey = 2;
      /// A stringified big.js. `Accepts variable expansion syntax.`
      string big = 3;
    }
  }

  /// Fetch the lending rates for various Solana protocols
  message LendingRateTask {
    /// 01, apricot, francium, jet, larix, mango, port, solend, tulip
    optional string protocol = 1;
    /// A token mint address supported by the chosen protocol
    optional string asset_mint = 2;
    enum Field {
      /// deposit lending rate
      FIELD_DEPOSIT_RATE = 0;
      /// borrow lending rate
      FIELD_BORROW_RATE = 1;
    }
    optional Field field = 3;
  }

  /// Fetch the current price for a Mango perpetual market
  message MangoPerpMarketTask {
    /// Mainnet address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
    optional string perp_market_address = 1;
  }

/*
Fetch the simulated price for a swap on JupiterSwap.

_**Input**_: None

_**Returns**_: The swap price on Jupiter for a given input and output token mint address.

_**Example**_: Fetch the JupiterSwap price for exchanging 1 SOL into USDC.

```json
{ "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" } }
```

_**Example**_: Fetch the JupiterSwap price for exchanging 1000 SOL into USDC.

```json
{ "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "baseAmount": "1000" } }
```
*/
  message JupiterSwapTask {
    /// The input token address.
    optional string in_token_address = 1;
    /// The output token address.
    optional string out_token_address = 2;

    message FilterList {
      /// A list of Jupiter AMM labels to allow or deny (e.g. 'Raydium', 'Orca')
      repeated string labels = 1;
    }

    oneof RoutesFilters {
      /// A list of AMM markets to allow.
      FilterList allow_list = 4;
      /// A list of AMM markets to deny.
      FilterList deny_list = 5;
    }

    oneof SwapAmount {
      /// The amount of `in_token_address` tokens to swap.
      double base_amount = 3;
      /// The amount of `out_token_address` tokens to swap.
      double quote_amount = 6;
      /// The amount of `in_token_address` tokens to swap.
      string base_amount_string = 7;
      /// The amount of `out_token_address` tokens to swap.
      string quote_amount_string = 8;
    }

    /// The allowable slippage on the swap in decimal form (e.g. 0.5 is 0.5% slippage)
    optional double slippage = 9;
  }

  /// Fetch the current price of a perpetual market.
  message PerpMarketTask {
    oneof MarketAddress {
      /// Market address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
      string mango_market_address = 1;
      /// Market address for a drift perpetual market. A full list can be found here: https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/constants/markets.ts
      string drift_market_address = 2;
      /// Market address for a zeta perpetual market.
      string zeta_market_address = 3;
      /// Market address for a 01 protocol perpetual market.
      string zo_market_address = 4;
    }
  }

/*
Fetch the current price of a Solana oracle protocol.

_**Input**_: None

_**Returns**_: The current price of an on-chain oracle.

_**Example**_: The Switchboard SOL/USD oracle price.

```json
{ "oracleTask": { "switchboardAddress": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR" } }
```

_**Example**_: The Pyth SOL/USD oracle price.

```json
{ "oracleTask": { "pythAddress": "H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG" } }
```

_**Example**_: The Chainlink SOL/USD oracle price.

```json
{ "oracleTask": { "chainlinkAddress": "CcPVS9bqyXbD9cLnTbhhHazLsrua8QMFUHTutPtjyDzq" } }
```
*/
  message OracleTask {
    oneof AggregatorAddress {
      /// Mainnet address of a Switchboard feed. Switchboard is decentralized and allows anyone to build their own feed.
      string switchboard_address = 1;
      /// Mainnet address for a Pyth feed. A full list can be found here: https://pyth.network/price-feeds/
      string pyth_address = 2;
      /// Mainnet address for a Chainlink feed. A full list can be found here: https://docs.chain.link/docs/solana/data-feeds-solana
      string chainlink_address = 3;
    }
    /// Value (as a percentage) that the lower bound confidence interval is of the actual value.
    /// Confidence intervals that are larger that this treshold are rejected.
    ///
    /// The confidence interval should be provided as a raw percentage value. For example, to
    /// represent 10%, enter the value as 10, not 0.1.
    optional double pyth_allowed_confidence_interval = 4;
  }

  /// Load a parse an Anchor based solana account.
  message AnchorFetchTask {
    /// Owning program of the account to parse.
    optional string program_id = 1;
    /// The account to parse.
    optional string account_address = 2;
  }


  /// Fetch the JSON representation of an SPL Stake Pool account.
  message SplStakePoolTask {
    /// The pubkey of the SPL Stake Pool.
    optional string pubkey = 1;
  }

  /// Fetch the JSON representation of an SPL token mint.
  message SplTokenParseTask {
    oneof AccountAddress {
      /// The publicKey of a token account to fetch the mintInfo for.
      string token_account_address = 1;
      /// The publicKey of the token mint address.
      string mint_address = 2;
    }
  }

  /// Fetch the swap price from UniSwap.
  message UniswapExchangeRateTask {
    enum Version {
      VERSION_V2 = 0;
      VERSION_V3 = 1;
    }
    /// The input token address.
    optional string in_token_address = 1;
    /// The output token address.
    optional string out_token_address = 2;
    /// The amount of tokens to swap.
    optional double in_token_amount = 3;
    /// The allowable slippage in percent for the swap.
    optional double slippage = 4;
    /// The RPC provider to use for the swap.
    optional string provider = 5;
    /// The version of the Uniswap exchange to use.
    optional Version version = 6;
  }

  /// Fetch the swap price from SushiSwap.
  message SushiswapExchangeRateTask {
     /// The input token address.
    optional string in_token_address = 1;
    /// The output token address.
    optional string out_token_address = 2;
    /// The amount of tokens to swap.
    optional double in_token_amount = 3;
    /// The allowable slippage in percent for the swap.
    optional double slippage = 4;
    /// The RPC provider to use for the swap.
    optional string provider = 5;
  }

  /// Fetch the swap price from PancakeSwap.
  message PancakeswapExchangeRateTask {
     /// The input token address.
    optional string in_token_address = 1;
    /// The output token address.
    optional string out_token_address = 2;
    /// The amount of tokens to swap.
    optional double in_token_amount = 3;
    /// The allowable slippage in percent for the swap.
    optional double slippage = 4;
    /// The RPC provider to use for the swap.
    optional string provider = 5;
  }


  /*
Execute a job and store the result in a variable to reference later.

_**Input**_: None

_**Returns**_: The input

_**Example**_: CacheTask storing ${ONE} = 1

```json
{ "cacheTask": { "cacheItems": [ { "variableName": "ONE", "job": { "tasks": [ { "valueTask": { "value": 1 } } ] } } ] } }
```
*/
  message CacheTask {
    message CacheItem {
      /// The name of the variable to store in cache to reference later with `${VARIABLE_NAME}`.
      optional string variable_name = 1;
      /// The OracleJob to execute to yield the value to store in cache.
      optional OracleJob job = 2;
    }
    /// A list of cached variables to reference in the job with `${VARIABLE_NAME}`.
    repeated CacheItem cache_items = 1;
  }

  /// Return the difference between an oracle's clock and the current timestamp at `SYSVAR_CLOCK_PUBKEY`.
  message SysclockOffsetTask {}

  message MarinadeStateTask {}

  /// Fetch the account data in a stringified buffer format.
  message SolanaAccountDataFetchTask {
    enum Network {
      NETWORK_MAINNET = 0;
      NETWORK_TESTNET = 1;
      NETWORK_DEVNET = 2;
    }
    /// The on-chain account to fetch the account data from.
    optional string pubkey = 1;
    optional Network network = 2;
  }

/*
Return a timestamp from a crontab instruction.

_**Input**_: None

_**Returns**_: A timestamp

_**Example**_: Return the unix timestamp for the on-chain SYSCLOCK

```json
{"cronParseTask":{"cronPattern":"* * * * * *","clockOffset":0,"clock":"SYSCLOCK"}}
```

_**Example**_: Return the unix timestamp for next friday at 5pm UTC

```json
{"cronParseTask":{"cronPattern":"0 17 * * 5","clockOffset":0,"clock":0}}
```
*/
  message CronParseTask {
    /// The cron pattern to parse.
    optional string cron_pattern = 1;
    /// The timestamp offset to calculate the next run.
    optional int32 clock_offset = 2;
    enum ClockType {
      /// Use the TaskRunners system clock for the current time.
      ORACLE = 0;
      /// Use the on-chain SYSCLOCK for the current time.
      SYSCLOCK = 1;
    }
    /// Use the TaskRunner's clock or the on-chain SYSCLOCK.
    optional ClockType clock = 3;
  }

  /// Return the deserialized value from a stringified buffer.
  message BufferLayoutParseTask {
    /// The buffer offset to start deserializing from.
    optional uint32 offset = 1;
    enum Endian {
      // Use little endian byte order.
      LITTLE_ENDIAN = 0;
      // Use big endian byte order.
      BIG_ENDIAN = 1;
    }
    /// The endianness of the stored value.
    optional Endian endian = 2;
    enum BufferParseType {
      /// A public key.
      pubkey = 1;
      /// A boolean.
      bool = 2;
      /// An 8-bit unsigned value.
      u8 = 3;
      /// An 8-bit signed value.
      i8 = 4;
      /// A 16-bit unsigned value.
      u16 = 5;
      /// A 16-bit signed value.
      i16 = 6;
      /// A 32-bit unsigned value.
      u32 = 7;
      /// A 32-bit signed value.
      i32 = 8;
      /// A 32-bit IEEE floating point value.
      f32 = 9;
      /// A 64-bit unsigned value.
      u64 = 10;
       /// A 64-bit signed value.
      i64 = 11;
      /// A 64-bit IEEE floating point value.
      f64 = 12;
      /// A 128-bit unsigned value.
      u128 = 13;
      /// A 128-bit signed value.
      i128 = 14;
    }
    /// The type of value to deserialize.
    optional BufferParseType type = 3;
  }

  message HistoryFunctionTask {
    enum Method {

      METHOD_MIN = 0;
      METHOD_MAX = 1;
    }
    optional Method method = 1;
    optional string aggregator_address = 2;
    optional uint32 period = 3;
  }

  message VwapTask {
    optional string price_aggregator_address = 1;
    optional string volume_aggregator_address = 2;
    optional uint32 period = 3;
  }

  message EwmaTask {
    optional string aggregator_address = 1;
    optional int32 period = 2;
    optional double lambda = 3;
  }

  message ComparisonTask {
    enum Operation {
      /// Use the equals to '==' operator.
      OPERATION_EQ = 0;
      /// Use the greater than '>' operator.
      OPERATION_GT = 1;
      /// Use the less than '<' operator.
      OPERATION_LT = 2;
    }
    /// The type of operator to use on the left (lhs) and right (rhs) operand.
    optional Operation op = 1;
    oneof LHS {
      /// OracleJob where the executed result is equal to the left hand side operand.
      OracleJob lhs = 2;
      /// String or `${CACHE_KEY}` representing the left hand side operand.
      string lhs_value = 3;
    }
    oneof RHS {
      /// OracleJob where the executed result is equal to the right hand side operand.
      OracleJob rhs = 4;
      /// String or `${CACHE_KEY}` representing the right hand side operand.
      string rhs_value = 5;
    }
    /// The OracleJob to execute if the condition evaluates to true.
    optional OracleJob on_true = 6;
    /// The result to use if the condition evaluates to true. Can be set to a `${CACHE_KEY}`.
    optional string on_true_value = 7;
    /// The OracleJob to execute if the condition evaluates to false.
    optional OracleJob on_false = 8;
    /// The result to use if the condition evaluates to false. Can be set to a `${CACHE_KEY}`.
    optional string on_false_value = 9;
    /// The OracleJob to execute if the condition fails to evaluate.
    optional OracleJob on_failure = 10;
     /// The result to use if the condition fails to evaluate. Can be set to a `${CACHE_KEY}`.
    optional string on_failure_value = 11;
  }

/*
Round the current running result to a set number of decimal places.

_**Input**_: The current running numerical result.

_**Returns**_: The running result rounded to a set number of decimal places.

_**Example**_: Round down the running resul to 8 decimal places

```json
{ "roundTask": { "method": "METHOD_ROUND_DOWN", "decimals": 8 } }
```
*/
  message RoundTask {
    enum Method {
      /// Round the result down.
      METHOD_ROUND_UP = 0;
      /// Round the result up.
      METHOD_ROUND_DOWN = 1;
    }
    /// The rounding method to use.
    optional Method method = 1;
    /// The number of decimals to round to.
    optional int32 decimals = 2;
  }

/*
Bound the running result to an upper/lower bound. This is typically the last task in an OracleJob.

_**Input**_: The current running numerical result.

_**Returns**_: The running result bounded to an upper or lower bound if it exceeds a given threshold.

_**Example**_: Bound the running result to a value between 0.90 and 1.10

```json
{ "boundTask": { "lowerBoundValue": "0.90","onExceedsLowerBoundValue": "0.90","upperBoundValue": "1.10","onExceedsUpperBoundValue": "1.10" } }
```
*/
  message BoundTask {
    /// The OracleJob to execute for the lower bound value.
    optional OracleJob lower_bound = 1;
    /// The value to use for the lower bound. Can be set to a `${CACHE_KEY}`.
    optional string lower_bound_value = 2;
    /// The OracleJob to execute for the upper bound value.
    optional OracleJob upper_bound = 3;
    /// The value to use for the upper bound. Can be set to a `${CACHE_KEY}`.
    optional string upper_bound_value = 4;
    /// The OracleJob to execute if the upper bound is exceeded.
    optional OracleJob on_exceeds_upper_bound = 5;
    /// The value to use if the upper bound is exceeded. Can be set to a `${CACHE_KEY}`.
    optional string on_exceeds_upper_bound_value = 6;
    /// The OracleJob to execute if the lower bound is exceeded.
    optional OracleJob on_exceeds_lower_bound = 7;
    /// The value to use if the lower bound is exceeded. Can be set to a `${CACHE_KEY}`.
    optional string on_exceeds_lower_bound_value = 8;
  }

/*
Securely request secrets from a Switchboard SecretsServer that are owned by a specific authority. Any secrets that are returned for the current feed will then be unwrapped into variables to be accessed later.

_**Input**_: None

_**Returns**_: The input

_**Example**_: SecretsTask

```json
{ "secretsTask": { "authority": "Accb21tUCWocJea6Uk3DgrNZawgmKegDVeHw8cGMDPi5" } }
```
*/
  message SecretsTask {
    /// The authority of the secrets that are to be requested.
    optional string authority = 1;
    /// The url of the server to request secrets from. The default is https://api.secrets.switchboard.xyz.
    optional string url = 2;
  }

  /// Grab the price of an Sanctum LST relative to SOL.
  message SanctumLstPriceTask {
    /// The address of the LST mint.
    ///
    /// e.g. INF - 5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm
    optional string lst_mint = 1;
  }

  /// OndoUsdyTask represents a task that computes the price of USDY relative to USD using a
  /// specified strategy.
  message OndoUsdyTask {
    /// Strategy specifies the method used to determine the price of USDY.
    ///
    /// - STRATEGY_FAIR_VALUE: Computes the price based on a fair value model.
    /// - STRATEGY_MARKET: Fetches the price directly from the market.
    enum Strategy {
      STRATEGY_FAIR_VALUE = 0;
      STRATEGY_MARKET = 1;
    }
    /// The strategy used to determine the price of USDY.
    optional Strategy strategy = 1;
  }

  /// Grab the swap price from a Meteora pool.
  message MeteoraSwapTask {
    enum Type {
      TYPE_DLMM = 0;
    }
    /// The address of the pool.
    optional string pool = 1;
    /// The pool type.
    optional Type type = 2;
  }

  /// Represents a singular operation performed by an oracle to yield an eventual numerical result.
  message Task {
    oneof Task {
      HttpTask http_task = 1;
      JsonParseTask json_parse_task = 2;
      MedianTask median_task = 4;
      MeanTask mean_task = 5;
      WebsocketTask websocket_task = 6;
      DivideTask divide_task = 7;
      MultiplyTask multiply_task = 8;
      LpTokenPriceTask lp_token_price_task = 9;
      LpExchangeRateTask lp_exchange_rate_task = 10;
      ConditionalTask conditional_task = 11;
      ValueTask value_task = 12;
      MaxTask max_task = 13;
      RegexExtractTask regex_extract_task = 14;
      XStepPriceTask xstep_price_task = 15;
      AddTask add_task = 16;
      SubtractTask subtract_task = 17;
      TwapTask twap_task = 18;
      SerumSwapTask serum_swap_task = 19;
      PowTask pow_task = 20;
      LendingRateTask lending_rate_task = 21;
      MangoPerpMarketTask mango_perp_market_task = 22;
      JupiterSwapTask jupiter_swap_task = 23;
      PerpMarketTask perp_market_task = 24;
      OracleTask oracle_task = 25;
      AnchorFetchTask anchor_fetch_task = 26;
      // reserved 27, 28;
      SplStakePoolTask spl_stake_pool_task = 29;
      SplTokenParseTask spl_token_parse_task = 30;
      UniswapExchangeRateTask uniswap_exchange_rate_task = 31;
      SushiswapExchangeRateTask sushiswap_exchange_rate_task = 32;
      PancakeswapExchangeRateTask pancakeswap_exchange_rate_task = 33;
      CacheTask cache_task = 34;
      SysclockOffsetTask sysclock_offset_task = 35;
      MarinadeStateTask marinade_state_task = 36;
      SolanaAccountDataFetchTask solana_account_data_fetch_task = 37;
      BufferLayoutParseTask buffer_layout_parse_task = 38;
      CronParseTask cron_parse_task = 39;
      MinTask min_task = 40;
      HistoryFunctionTask history_function_task = 41;
      VwapTask vwap_task = 42;
      EwmaTask ewma_task = 43;
      ComparisonTask comparison_task = 44;
      RoundTask round_task = 45;
      BoundTask bound_task = 46;
      SecretsTask secrets_task = 47;
      SanctumLstPriceTask sanctum_lst_price_task = 48;
      OndoUsdyTask ondo_usdy_task = 49;
      MeteoraSwapTask meteora_swap_task = 50;
    }
  }
  /// The chain of tasks to perform for this OracleJob.
  repeated Task tasks = 1;

}
